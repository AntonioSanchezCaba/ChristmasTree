<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üéÑ Christmas LED Tree - 3D WLED Edition</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: radial-gradient(ellipse at bottom, #1b2735 0%, #090a0f 100%);
            overflow: hidden;
            height: 100vh;
            color: #333;
        }
        
        .stars {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        
        .star {
            position: absolute;
            width: 2px;
            height: 2px;
            background: white;
            border-radius: 50%;
            animation: twinkle 3s infinite;
        }
        
        @keyframes twinkle {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 1; }
        }
        
        .main-container {
            display: flex;
            height: 100vh;
            position: relative;
            z-index: 1;
        }
        
        .tree-view {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
            position: relative;
        }
        
        .tree-container {
            position: relative;
            width: 90%;
            height: 90%;
            max-width: 800px;
            max-height: 900px;
        }
        
        #treeCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: grab;
        }
        #treeCanvas:active {
            cursor: grabbing;
        }
        
        /* BOT√ìN SCHEDULE FLOTANTE */
        /* BOT√ìN SCHEDULE MINIMALISTA */
        .schedule-button {
            position: fixed;
            top: 15px;
            right: 470px;
            background: linear-gradient(135deg, #4776E6 0%, #8E54E9 100%);
            color: white;
            border: none;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 10px rgba(71, 118, 230, 0.4);
            transition: all 0.3s;
            z-index: 100;
        }

        .schedule-button span {
            display: none;
            /* Oculta el texto */
        }

        .schedule-button:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 15px rgba(71, 118, 230, 0.6);
        }

        /* Tooltip al pasar el mouse */
        .schedule-button::after {
            content: 'Schedule';
            position: absolute;
            bottom: -30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }

        .schedule-button:hover::after {
            opacity: 1;
        }
        
        /* MODAL DE SCHEDULE */
        .schedule-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            z-index: 1000;
        }
        
        .schedule-modal.active {
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        .schedule-container {
            background: white;
            width: 90%;
            max-width: 1200px;
            height: 85vh;
            border-radius: 20px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            animation: slideUp 0.3s;
        }
        
        @keyframes slideUp {
            from {
                transform: translateY(50px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }
        
        .schedule-header {
            background: linear-gradient(135deg, #4776E6 0%, #8E54E9 100%);
            color: white;
            padding: 20px 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .schedule-header h2 {
            font-size: 24px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .close-schedule {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 24px;
            font-weight: bold;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            line-height: 1;
        }

        .close-schedule:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: rotate(90deg) scale(1.1);
        }

        .close-schedule:active {
            transform: rotate(90deg) scale(0.95);
        }
        
        .schedule-body {
            flex: 1;
            overflow-y: auto;
            padding: 30px;
            background: #f8f9fa;
        }
        
        .schedule-grid {
            display: grid;
            grid-template-columns: 100px 1fr;
            gap: 20px;
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }
        
        .time-column {
            display: flex;
            flex-direction: column;
            gap: 40px;
            padding-top: 40px;
        }
        
        .time-label {
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            padding-right: 10px;
            font-size: 12px;
            color: #666;
            border-top: 1px solid #e0e0e0;
        }
        
        .days-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 10px;
        }
        
        .day-column {
            background: #fff;
            border: 1px solid #e0e0e0;
            border-radius: 10px;
            overflow: hidden;
        }
        
        .day-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 10px;
            text-align: center;
            font-weight: 600;
            font-size: 14px;
        }
        
        .day-schedule {
            position: relative;
            height: 1440px;
            background: repeating-linear-gradient(
                to bottom,
                #fff 0px,
                #fff 59px,
                #f5f5f5 59px,
                #f5f5f5 60px
            
            );
        }
        
        .schedule-block {
            position: absolute;
            left: 5px;
            right: 5px;
            background: #4CAF50;
            color: white;
            border-radius: 5px;
            padding: 5px;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            /* INICIO: Soluci√≥n #2 - Ocultar texto si es muy peque√±o */
            overflow: hidden; 
            /* FIN: Soluci√≥n #2 */
        }
        
        .schedule-block:hover {
            transform: scale(1.02);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
        }
        
        .schedule-block.inactive {
            background: #9e9e9e;
            opacity: 0.7;
        }
        
        .add-schedule-panel {
            background: white;
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }
        
        .quick-actions {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .quick-action-btn {
            flex: 1;
            padding: 10px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
        }
        
        .quick-action-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 10px rgba(102, 126, 234, 0.4);
        }
        
        .control-panel {
            width: 450px;
            background: rgba(255, 255, 255, 0.98);
            overflow-y: auto;
            box-shadow: -5px 0 30px rgba(0,0,0,0.3);
            display: flex;
            flex-direction: column;
        }
        
        .panel-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px 20px; /* Reducido de 20px */
            text-align: center;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .panel-header h1 {
            font-size: 1.5em;
            /* Reducido de 1.8em */
            margin-bottom: 3px;
        }

        .panel-header p {
            font-size: 0.9em;
            /* M√°s peque√±o */
            opacity: 0.9;
        }
        
        .panel-content {
            padding: 20px;
            flex-grow: 1;
        }
        
        .section {
            background: white;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .section-title {
            font-size: 1.1em;
            font-weight: 600;
            color: #333;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .connection-status {
            padding: 10px;
            border-radius: 8px;
            text-align: center;
            font-weight: 600;
            margin-bottom: 15px;
        }
        
        .connection-status.connected {
            background: #d4edda;
            color: #155724;
        }
        
        .connection-status.disconnected {
            background: #f8d7da;
            color: #721c24;
        }
        
        .connection-status.connecting {
            background: #fff3cd;
            color: #856404;
        }
        
        .info-box {
            background: #e7f3ff;
            border-left: 4px solid #2196F3;
            padding: 12px;
            margin-bottom: 15px;
            border-radius: 4px;
            font-size: 13px;
        }
        
        .debug-log {
            background: #f5f5f5;
            border: 1px solid #ddd;
            border-radius: 6px;
            padding: 10px;
            max-height: 200px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            margin-top: 10px;
        }
        
        .debug-log div {
            margin: 2px 0;
            padding: 2px;
        }
        
        .debug-log .success {
            color: #28a745;
        }
        
        .debug-log .error {
            color: #dc3545;
        }
        
        .debug-log .info {
            color: #007bff;
        }
        
        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s;
            width: 100%;
            margin-bottom: 10px;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        button:active {
            transform: translateY(0);
            box-shadow: 0 2px 6px rgba(102, 126, 234, 0.3);
        }
        
        button.active {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            box-shadow: 0 0 20px rgba(79, 172, 254, 0.6);
        }
        
        button.danger {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }
        button.danger:hover {
            box-shadow: 0 4px 12px rgba(245, 87, 108, 0.4);
        }
        
        .color-selector {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-bottom: 15px;
        }
        
        input[type="color"] {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            width: 60px;
            height: 60px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            padding: 0;
            background-color: transparent;
        }
        input[type="color"]::-webkit-color-swatch-wrapper {
            padding: 0;
            border: 3px solid #ddd;
            border-radius: 8px;
        }
        input[type="color"]::-webkit-color-swatch {
            border: none;
            border-radius: 5px;
        }
        input[type="color"]::-moz-color-swatch {
            border: none;
            border-radius: 5px;
        }
        
        .brightness-control {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 15px 0;
        }
        
        input[type="range"] {
            flex: 1;
            height: 8px;
            border-radius: 5px;
            background: #ddd;
            outline: none;
            -webkit-appearance: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
        }
        
        .brightness-value {
            min-width: 50px;
            text-align: right;
            font-weight: 600;
            color: #667eea;
        }
        
        input[type="text"], input[type="time"] {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 14px;
            margin-bottom: 10px;
            transition: border 0.3s;
        }
        
        input[type="text"]:focus, input[type="time"]:focus {
            outline: none;
            border-color: #667eea;
        }
        
        .effects-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }
        
        .effect-btn {
            margin: 0;
            padding: 10px;
            font-size: 13px;
        }
        
        .color-palette {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 8px;
            margin-top: 10px;
        }
        
        .palette-color {
            width: 100%;
            aspect-ratio: 1;
            border-radius: 8px;
            cursor: pointer;
            border: 3px solid transparent;
            transition: all 0.3s;
        }
        
        .palette-color:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }
        
        .palette-color.selected {
            border-color: #667eea;
            transform: scale(1.1);
        }
        
        .design-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 8px;
            margin-bottom: 8px;
        }
        
        .design-item button {
            width: auto;
            margin: 0 5px;
            padding: 8px 15px;
        }
        
        .delete-btn {
            background: #dc3545 !important;
            padding: 8px 12px !important;
        }
        
        .status-message {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #28a745;
            color: white;
            padding: 15px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            z-index: 1000;
            animation: slideIn 0.3s;
        }
        
        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        
        .animated-effects-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }
        
        .animated-effects-grid button {
            margin: 0;
            padding: 10px;
            font-size: 13px;
        }
        
        .animated-effects-grid button:last-child {
            grid-column: 1 / -1;
        }
        
        @media (max-width: 1024px) {
            .main-container {
                flex-direction: column;
            }
            
            .control-panel {
                width: 100%;
                max-height: 50vh;
            }
            
            .tree-view {
                height: 50vh;
            }
            
            .schedule-button {
                right: 20px;
            }
        }

        /* INICIO: Soluci√≥n #4 - Responsividad del Modal Schedule */
        @media (max-width: 768px) {
            
            /* Hacer el modal full-screen en m√≥vil */
            .schedule-container {
                width: 100vw;
                height: 100vh;
                max-width: 100vw;
                max-height: 100vh;
                height: 100%;
                border-radius: 0;
            }

            .schedule-header h2 {
                font-size: 18px;
                gap: 5px;
            }

            .close-schedule {
                width: 35px;
                height: 35px;
                font-size: 20px;
            }

            .schedule-body {
                padding: 10px;
            }

            /* Apilar acciones r√°pidas verticalmente */
            .quick-actions {
                flex-direction: column;
                gap: 8px;
            }

            .add-schedule-panel {
                padding: 15px;
            }

            /* Forzar que los selectores de d√≠a se envuelvan */
            [style*="grid-template-columns: repeat(7, 1fr)"] {
                grid-template-columns: repeat(4, 1fr) !important;
                gap: 10px !important;
            }

            /* Apilar Inicio, Fin y Bot√≥n de agregar */
            [style*="grid-template-columns: 1fr 1fr auto"] {
                grid-template-columns: 1fr !important;
                gap: 15px !important;
            }
            [style*="grid-template-columns: 1fr 1fr auto"] button {
                width: 100% !important;
            }


            /* Hacer que la grilla de d√≠as tenga scroll horizontal */
            .schedule-grid {
                grid-template-columns: 60px 1fr; /* Reducir columna de hora */
                gap: 10px;
                padding: 10px;
                /* Permitir que la grilla se desborde */
                overflow-x: auto;
            }

            .time-column {
                gap: 40px; /* Mantener alineaci√≥n */
            }

            .time-label {
                font-size: 10px;
                padding-right: 5px;
            }

            .days-grid {
                /* Forzar las 7 columnas, pero permitir scroll */
                grid-template-columns: repeat(7, 120px); /* Ancho fijo para cada d√≠a */
                gap: 5px;
            }

            .day-header {
                font-size: 12px;
            }
        }
        /* FIN: Soluci√≥n #4 */

    </style>
</head>
<body>
    <div id="stars" class="stars"></div>
    
    <button class="schedule-button" onclick="openSchedule()">
        üìÖ <span style="font-size: 12px;">Schedule</span>
    </button>
    
    <div id="scheduleModal" class="schedule-modal">
        <div class="schedule-container">
            <div class="schedule-header">
                <h2>üìÖ Programaci√≥n de Horarios LED</h2>
                <button class="close-schedule" onclick="closeSchedule()" aria-label="Cerrar">‚úï</button>
            </div>
            
            <div class="schedule-body">
                <div class="add-schedule-panel">
                    <h3 style="margin-bottom: 15px; color: #667eea;">‚ö° Acciones R√°pidas</h3>
                    <div class="quick-actions">
                        <button class="quick-action-btn" onclick="setWeekdaySchedule()">
                             üíº Lun-Vie (7:00-21:00)
                        </button>
                        <button class="quick-action-btn" onclick="setWeekendSchedule()">
                            üèñÔ∏è Fin de Semana (9:00-23:00)
                        </button>
                        <button class="quick-action-btn" onclick="setEveningSchedule()">
                            üåô Solo Tardes (17:00-23:00)
                        </button>
                        <button class="quick-action-btn" onclick="clearAllSchedules()" style="background: #dc3545;">
                            üóëÔ∏è Limpiar Todo
                        </button>
                    </div>
    
                    
                    <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin-top: 15px;">
                        <h4 style="margin-top: 0; color: #667eea;">‚ûï Agregar Horario Personalizado</h4>
                        
                        <div style="display: grid; grid-template-columns: repeat(7, 1fr); gap: 5px; margin-bottom: 15px;">
                            <label style="display: flex; align-items: center; font-size: 13px;">
                                <input type="checkbox" id="day-0" style="margin-right: 3px;"> Dom
                            </label>
                            <label style="display: flex; align-items: center; font-size: 13px;">
                                <input type="checkbox" id="day-1" style="margin-right: 3px;"> Lun
                            </label>
                            <label style="display: flex; align-items: center; font-size: 13px;">
                                <input type="checkbox" id="day-2" style="margin-right: 3px;"> Mar
                            </label>
                            <label style="display: flex; align-items: center; font-size: 13px;">
                                <input type="checkbox" id="day-3" style="margin-right: 3px;"> Mi√©
                            </label>
                            <label style="display: flex; align-items: center; font-size: 13px;">
                                <input type="checkbox" id="day-4" style="margin-right: 3px;"> Jue
                            </label>
                            <label style="display: flex; align-items: center; font-size: 13px;">
                                <input type="checkbox" id="day-5" style="margin-right: 3px;"> Vie
                            </label>
                            <label style="display: flex; align-items: center; font-size: 13px;">
                                <input type="checkbox" id="day-6" style="margin-right: 3px;"> S√°b
                            </label>
                        </div>
        
                        
                        <div style="display: grid; grid-template-columns: 1fr 1fr auto; gap: 10px; align-items: end;">
                            <div>
                                <label style="font-size: 12px; color: #666;">Hora Inicio:</label>
                                <input type="time" id="scheduleStartTime" value="07:00" style="margin: 0;">
                            </div>
                            <div>
                                 <label style="font-size: 12px; color: #666;">Hora Fin:</label>
                                <input type="time" id="scheduleEndTime" value="21:00" style="margin: 0;">
                            </div>
                            <button onclick="addSchedule()" style="background: #28a745; margin: 0; width: auto; padding: 10px 20px;">
                                ‚ûï Agregar
                            </button>
                        </div>
                    </div>
                    
                    <div style="margin-top: 20px; padding: 15px; background: #e7f3ff; border-radius: 8px; border-left: 4px solid #2196F3;">
                        <label style="display: flex; align-items: center; gap: 10px; font-weight: 600;">
                            <input type="checkbox" id="schedulerEnabled" onchange="updateScheduler()" style="width: 20px; height: 20px;">
                            <span>üîå Activar Programaci√≥n Autom√°tica</span>
                        </label>
                        <p style="margin-top: 10px; margin-bottom: 0; font-size: 13px; color: #666;">
                            Estado: <span id="scheduleStatusText" style="font-weight: 600;">Desactivado</span>
                        </p>
                    </div>
                </div>
   
                 
                <div class="schedule-grid">
                    <div class="time-column">
                        <div class="time-label">00:00</div>
                         <div class="time-label">02:00</div>
                        <div class="time-label">04:00</div>
                        <div class="time-label">06:00</div>
                        <div class="time-label">08:00</div>
                         <div class="time-label">10:00</div>
                        <div class="time-label">12:00</div>
                        <div class="time-label">14:00</div>
                        <div class="time-label">16:00</div>
                         <div class="time-label">18:00</div>
                        <div class="time-label">20:00</div>
                        <div class="time-label">22:00</div>
                    </div>
                       
                    <div class="days-grid" id="scheduleGrid">
                        </div>
                </div>
            </div>
        </div>
    </div>
    
    <div class="main-container">
        <div class="tree-view">
            <div class="tree-container">
                <canvas id="treeCanvas"></canvas>
            </div>
        </div>
        
   
         <div class="control-panel">
            <div class="panel-header">
                <h1>üéÑ Christmas LED Tree</h1>
                <p>3D WLED Edition - Mosquitto</p>
            </div>
            
            <div class="panel-content">
     
                <div class="section">
                    <div class="section-title">üîå Conexi√≥n MQTT</div>
                    
                    <div class="connection-status connecting" id="connectionStatus">
                         üîÑ Conectando...
                    </div>
                    
                    <div class="info-box">
                         <strong>üì° Servidor:</strong> mqtt.vittence.com<br>
                        <strong>üîí Protocolo:</strong> WebSocket Secure (WSS) - Puerto 8084<br>
                        <strong>üéØ Topic:</strong> wled/tree/api<br>
                        <strong>‚úÖ SSL:</strong> Certificado Let's Encrypt v√°lido<br>
                         <strong>üåê Compatible:</strong> Funciona desde HTTPS
                    </div>
                    
                    <button onclick="reconnectMQTT()">üîÑ Reconectar MQTT</button>
                     <button onclick="sendTestMessage()">üì§ Enviar Mensaje de Prueba</button>
                    <button onclick="resetWLED()" class="danger">üî¥ Apagar LEDs</button>
                    
                    <div class="debug-log" id="debugLog"></div>
                </div>
               
                <div class="section">
                    <div class="section-title">üé® LED Color</div>
                    <div class="color-selector">
                         <input type="color" id="ledColor" value="#ff0000" onchange="updateSelectedColor()">
                        <button onclick="activatePaintMode()" id="paintBtn">Activar Paint Mode</button>
                    </div>
                    
                     <div id="colorPalette" class="color-palette" style="display: none;">
                        <div class="palette-color selected" style="background: #ff0000" onclick="selectPaletteColor('#ff0000')"></div>
                        <div class="palette-color" style="background: #ffa500" onclick="selectPaletteColor('#ffa500')"></div>
                        <div class="palette-color" style="background: #ffff00" onclick="selectPaletteColor('#ffff00')"></div>
                         <div class="palette-color" style="background: #ffffff" onclick="selectPaletteColor('#ffffff')"></div>
                        <div class="palette-color" style="background: #00ff00" onclick="selectPaletteColor('#00ff00')"></div>
                        <div class="palette-color" style="background: #0000ff" onclick="selectPaletteColor('#0000ff')"></div>
                         <div class="palette-color" style="background: #4b0082" onclick="selectPaletteColor('#4b0082')"></div>
                        <div class="palette-color" style="background: #ee82ee" onclick="selectPaletteColor('#ee82ee')"></div>
                        <div class="palette-color" style="background: #333333" onclick="selectPaletteColor('#333333')"></div>
                    </div>
                </div>
 
                <div class="section">
                    <div class="section-title">üí° Brightness</div>
                    <div class="brightness-control">
                         <input type="range" id="brightness" min="0" max="255" value="128" oninput="setBrightness(this.value)">
                        <span class="brightness-value" id="brightVal">50%</span>
                    </div>
                </div>

                <!-- Control B√°sico -->
                <div class="section">
                    <div class="section-title">‚ö° Control</div>
                    <div class="effects-grid">
                        <button class="effect-btn" onclick="setStaticDesign('OFF')" style="background: #dc3545;">üî¥ OFF</button>
                        <button class="effect-btn" onclick="runEffect(0)">‚ö™ Solid (Static)</button>
                    </div>
                </div>

                <!-- Color Palettes -->
                <div class="section">
                    <div class="section-title">üé® Color Palettes</div>
                    <div class="effects-grid">
                        <button class="effect-btn" onclick="setPalette(2)">üíú Purple Rain</button>
                        <button class="effect-btn" onclick="setPalette(255)">üá©üá¥ Dominican</button>
                        <button class="effect-btn" onclick="setPalette(35)">üî• Fire</button>
                        <button class="effect-btn" onclick="setPalette(9)">üåä Ocean</button>
                        <button class="effect-btn" onclick="setPalette(8)">üåã Lava</button>
                        <button class="effect-btn" onclick="setPalette(11)">üåà Rainbow</button>
                        <button class="effect-btn" onclick="setPalette(10)">üå≤ Forest</button>
                        <button class="effect-btn" onclick="setPalette(13)">üåÖ Sunset</button>
                        <button class="effect-btn" onclick="setPalette(26)">üèñÔ∏è Beach</button>
                        <button class="effect-btn" onclick="setPalette(6)">üéâ Party</button>
                        <button class="effect-btn" onclick="setPalette(20)">üå∏ Pastel</button>
                        <button class="effect-btn" onclick="setPalette(7)">‚òÅÔ∏è Cloud</button>
                        <button class="effect-btn" onclick="setPalette(50)">‚ú® Aurora</button>
                        <button class="effect-btn" onclick="setPalette(48)">üéÑ C9 (Christmas)</button>
                    </div>
                </div>

                <!-- Effect Modes -->
                <div class="section">
                    <div class="section-title">‚ö° Effect Modes</div>
                    <div class="effects-grid">
                        <button class="effect-btn" onclick="runEffect(1)">üí´ Blink</button>
                        <button class="effect-btn" onclick="runEffect(2)">üå¨Ô∏è Breathe</button>
                        <button class="effect-btn" onclick="runEffect(9)">üåà Rainbow</button>
                        <button class="effect-btn" onclick="runEffect(10)">üì° Scan</button>
                        <button class="effect-btn" onclick="runEffect(17)">‚ú® Twinkle</button>
                        <button class="effect-btn" onclick="runEffect(20)">‚≠ê Sparkle</button>
                        <button class="effect-btn" onclick="runEffect(28)">üèÉ Chase</button>
                        <button class="effect-btn" onclick="runEffect(38)">üåå Aurora</button>
                        <button class="effect-btn" onclick="runEffect(42)">üéÜ Fireworks</button>
                        <button class="effect-btn" onclick="runEffect(45)">üåã Lava</button>
                        <button class="effect-btn" onclick="runEffect(67)">üåÄ Colorwaves</button>
                        <button class="effect-btn" onclick="runEffect(76)">‚òÑÔ∏è Meteor</button>
                        <button class="effect-btn" onclick="runEffect(79)">üíß Ripple</button>
                        <button class="effect-btn" onclick="runEffect(101)">üå¥ Pacifica</button>
                        <button class="effect-btn" onclick="runEffect(110)">üé® Flow</button>
                    </div>
                </div>

                <div class="section">
                    <div class="section-title">üìÅ Saved Designs</div>
                     <input type="text" id="designName" placeholder="Design name">
                    <button onclick="saveDesign()">üíæ Save Current Design</button>
                    <div id="designsList"></div>
                </div>
            </div>
        </div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/mqtt@4.3.7/dist/mqtt.min.js"></script>
    
    <script>
        // =====================================================
        // VARIABLES GLOBALES
        // =====================================================
        
        let scene, camera, renderer;
        let ledGroup;
        let ledMeshes = [];
        let ledColors = {};
        let ledPositions = [];
        
        const totalLeds = 179;
        let paintMode = false;
        let selectedColor = '#ff0000';
        let currentBrightness = 128;
        
        let effectAnimationInterval = null;
        let localAnimationInterval = null;
        let currentEffect = null;
        let currentLocalAnimation = null;
        let currentEffectId = 0; // Efecto actual de WLED (fx)
        let currentPaletteId = 0; // Paleta actual de WLED (pal)

        // Variable para guardar el √∫ltimo estado de WLED
        let pendingWLEDState = null;
        let ledsReady = false;

        // Protecci√≥n contra loops: rastrear √∫ltimo estado procesado
        let lastProcessedState = null;
        let lastProcessedTime = 0;

        // CONFIGURACI√ìN MQTT MOSQUITTO
        let mqttClient = null;
        const MQTT_CONFIG = {
            broker: 'wss://mqtt.vittence.com:8084/mqtt',
            topic: 'wled/tree/api',
            username: '',
            password: ''
        };
        let COLOR_ORDER = 'RGB';
        
        // VARIABLES DE PROGRAMACI√ìN
        let schedules = [];
        let schedulerInterval = null;
        let lastScheduleState = null;
        
        // D√≠as de la semana
        const DAYS = ['Domingo', 'Lunes', 'Martes', 'Mi√©rcoles', 'Jueves', 'Viernes', 'S√°bado'];
        const DAYS_SHORT = ['Dom', 'Lun', 'Mar', 'Mi√©', 'Jue', 'Vie', 'S√°b'];
        // =====================================================
        // FUNCIONES DE SCHEDULE MODAL
        // =====================================================
        
        function openSchedule() {
            const modal = document.getElementById('scheduleModal');
            if (modal) {
                modal.classList.add('active');
                loadSchedules();
                renderScheduleGrid();
                updateSchedulerStatus();
            }
        }

        function closeSchedule() {
            const modal = document.getElementById('scheduleModal');
            if (modal) {
                modal.classList.remove('active');
            }
        }
        
        function closeSchedule() {
            const modal = document.getElementById('scheduleModal');
            modal.classList.add('closing');
    
            setTimeout(() => {
                modal.classList.remove('active');
                modal.classList.remove('closing');
            }, 300);
        }
        
        // =====================================================
        // SISTEMA DE PROGRAMACI√ìN AVANZADO
        // =====================================================
        
        function loadSchedules() {
            const savedSchedules = localStorage.getItem('wledSchedules');
            if (savedSchedules) {
                schedules = JSON.parse(savedSchedules);
            }
            
            const enabled = localStorage.getItem('schedulerEnabled') === 'true';
            document.getElementById('schedulerEnabled').checked = enabled;
        }
        
        function saveSchedules() {
            localStorage.setItem('wledSchedules', JSON.stringify(schedules));
            renderScheduleGrid();

            // Publicar horarios en MQTT para sincronizar entre dispositivos
            if (mqttClient && mqttClient.connected) {
                const schedulesData = {
                    schedules: schedules,
                    enabled: document.getElementById('schedulerEnabled').checked,
                    timestamp: Date.now()
                };
                mqttClient.publish('wled/tree/schedules', JSON.stringify(schedulesData), { retain: true });
                addDebugLog('üì§ Horarios publicados para sincronizaci√≥n', 'success');
            }
        }
        
        function addSchedule() {
            const selectedDays = [];
            for (let i = 0; i < 7; i++) {
                if (document.getElementById(`day-${i}`).checked) {
                    selectedDays.push(i);
                }
            }
            
            if (selectedDays.length === 0) {
                showStatus('‚ùå Selecciona al menos un d√≠a', true);
                return;
            }
            
            const startTime = document.getElementById('scheduleStartTime').value;
            const endTime = document.getElementById('scheduleEndTime').value;
            
            if (!startTime || !endTime) {
                showStatus('‚ùå Define las horas de inicio y fin', true);
                return;
            }
            
            const schedule = {
                id: Date.now(),
                days: selectedDays,
                startTime: startTime,
                endTime: endTime,
    
                enabled: true
            };
            schedules.push(schedule);
            saveSchedules();
            
            // Limpiar formulario
            for (let i = 0; i < 7; i++) {
                document.getElementById(`day-${i}`).checked = false;
            }
            document.getElementById('scheduleStartTime').value = '07:00';
            document.getElementById('scheduleEndTime').value = '21:00';
            showStatus('‚úÖ Horario agregado correctamente');
            addDebugLog('üìÖ Nuevo horario agregado', 'success');
        }
        
        function deleteSchedule(id) {
            schedules = schedules.filter(s => s.id !== id);
            saveSchedules();
            showStatus('‚úÖ Horario eliminado');
            addDebugLog('üóëÔ∏è Horario eliminado', 'info');
        }
        
        function toggleSchedule(id) {
            const schedule = schedules.find(s => s.id === id);
            if (schedule) {
                schedule.enabled = !schedule.enabled;
                saveSchedules();
                addDebugLog(`üìÖ Horario ${schedule.enabled ? 'activado' : 'desactivado'}`, 'info');
            }
        }
        
        // INICIO: Soluci√≥n #3 - Modificaci√≥n de renderScheduleGrid para overnight
        function renderScheduleGrid() {
            const grid = document.getElementById('scheduleGrid');
            grid.innerHTML = '';
            
            // Crear columnas para cada d√≠a
            for (let day = 0; day < 7; day++) {
                const dayColumn = document.createElement('div');
                dayColumn.className = 'day-column';
                
                const dayHeader = document.createElement('div');
                dayHeader.className = 'day-header';
                dayHeader.textContent = DAYS_SHORT[day];
                
                const daySchedule = document.createElement('div');
                daySchedule.className = 'day-schedule';
                
                // Agregar bloques de horario para este d√≠a
                schedules.forEach(schedule => {
                    // Los horarios desactivados se muestran en gris (con clase 'inactive')
                    const [startH, startM] = schedule.startTime.split(':').map(Number);
                    const [endH, endM] = schedule.endTime.split(':').map(Number);
                    
                    const startMinutes = startH * 60 + startM;
                    const endMinutes = endH * 60 + endM;

                    const isOvernight = endMinutes < startMinutes;

                    if (!isOvernight) {
                        // --- Horario Normal (mismo d√≠a) ---
                        if (schedule.days.includes(day)) {
                            const block = createScheduleBlock(schedule, startMinutes, endMinutes);
                            daySchedule.appendChild(block);
                        }
                    } else {
                        // --- Horario Overnight (pasa la medianoche) ---
                        
                        // 1. Parte que *empieza* hoy y termina ma√±ana
                        if (schedule.days.includes(day)) {
                            const block = createScheduleBlock(schedule, startMinutes, 1440); // 1440 = 24:00
                            daySchedule.appendChild(block);
                        }

                        // 2. Parte que *termina* hoy (empez√≥ ayer)
                        const prevDay = (day === 0) ? 6 : day - 1; // 6 = S√°bado
                        if (schedule.days.includes(prevDay)) {
                            const block = createScheduleBlock(schedule, 0, endMinutes); // 0 = 00:00
                            daySchedule.appendChild(block);
                        }
                    }
                });

                dayColumn.appendChild(dayHeader);
                dayColumn.appendChild(daySchedule);
                grid.appendChild(dayColumn);
            }
        }
        // FIN: Soluci√≥n #3

        // INICIO: Soluci√≥n #2 y #3 - Modificaci√≥n de createScheduleBlock
        // (Ahora acepta startMinutes y endMinutes para manejar bloques divididos)
        function createScheduleBlock(schedule, startMinutes, endMinutes) {
            
            const block = document.createElement('div');
            block.className = `schedule-block ${schedule.enabled ? '' : 'inactive'}`;
            
            // Calcular posici√≥n y altura
            const top = startMinutes; // 1 pixel por minuto
            const height = endMinutes - startMinutes;
            
            block.style.top = `${top}px`;
            block.style.height = `${height}px`;
            
            // Soluci√≥n #2: Solo mostrar texto si el bloque es lo suficientemente alto
            if (height >= 40) { // 40 minutos o m√°s
                block.innerHTML = `
                    <strong>${schedule.startTime}</strong>
                    <span>a</span>
                    <strong>${schedule.endTime}</strong>
                `;
            } else {
                // Si es muy peque√±o, al menos poner un tooltip
                block.title = `${schedule.startTime} - ${schedule.endTime}`;
            }
            
            // L√≥gica: 1 click = Activar/Desactivar. 2 clicks = Eliminar.
            // Usamos un sistema de detecci√≥n de doble click para evitar conflictos
            let clickTimer = null;
            let clickCount = 0;

            block.addEventListener('click', (e) => {
                e.preventDefault();
                clickCount++;

                if (clickCount === 1) {
                    // Primer click: esperar para ver si hay un segundo click
                    clickTimer = setTimeout(() => {
                        // Solo hubo un click ‚Üí toggle activar/desactivar
                        toggleSchedule(schedule.id);
                        clickCount = 0;
                    }, 250); // 250ms de espera para detectar doble click
                } else if (clickCount === 2) {
                    // Segundo click ‚Üí eliminar
                    clearTimeout(clickTimer);
                    clickCount = 0;

                    if (confirm('¬øEst√°s seguro de que deseas ELIMINAR este horario permanentemente?')) {
                        deleteSchedule(schedule.id);
                    }
                }
            });

            return block;
        }
        // FIN: Soluci√≥n #2 y #3
        
        // Funciones de horarios r√°pidos
        function setWeekdaySchedule() {
            const schedule = {
                id: Date.now(),
                days: [1, 2, 3, 4, 5],
                startTime: '07:00',
                endTime: '21:00',
                enabled: true
            };
            schedules.push(schedule);
            saveSchedules();
            showStatus('‚úÖ Horario Lun-Vie agregado');
        }
        
        function setWeekendSchedule() {
            const schedule = {
                id: Date.now(),
                days: [0, 6],
                startTime: '09:00',
                 endTime: '23:00',
                enabled: true
            };
            schedules.push(schedule);
            saveSchedules();
            showStatus('‚úÖ Horario Fin de Semana agregado');
        }
        
        function setEveningSchedule() {
            const schedule = {
                id: Date.now(),
                days: [0, 1, 2, 3, 4, 5, 6],
                startTime: '17:00',
                endTime: '23:00',
                enabled: true
            };
            schedules.push(schedule);
            saveSchedules();
            showStatus('‚úÖ Horario de Tardes agregado');
        }
        
        function clearAllSchedules() {
            if (confirm('¬øEliminar TODOS los horarios programados?')) {
                schedules = [];
                saveSchedules();
                showStatus('‚úÖ Todos los horarios eliminados');
            }
        }
        
        function updateScheduler() {
            const enabled = document.getElementById('schedulerEnabled').checked;
            localStorage.setItem('schedulerEnabled', enabled.toString());

            updateSchedulerStatus();

            if (enabled) {
                showStatus('‚úÖ Programaci√≥n autom√°tica activada');
                addDebugLog('‚è∞ Programaci√≥n autom√°tica activada', 'success');
                checkSchedules();
            } else {
                showStatus('‚è∏Ô∏è Programaci√≥n autom√°tica desactivada');
                addDebugLog('‚è∞ Programaci√≥n autom√°tica desactivada', 'info');
            }

            // Publicar cambio en MQTT para sincronizar entre dispositivos
            if (mqttClient && mqttClient.connected) {
                const schedulesData = {
                    schedules: schedules,
                    enabled: enabled,
                    timestamp: Date.now()
                };
                mqttClient.publish('wled/tree/schedules', JSON.stringify(schedulesData), { retain: true });
                addDebugLog('üì§ Estado del scheduler publicado', 'success');
            }
        }
        
        function updateSchedulerStatus() {
            // Verificar que el elemento exista antes de usarlo
            const schedulerCheckbox = document.getElementById('schedulerEnabled');
            const statusText = document.getElementById('scheduleStatusText');
    
            if (!schedulerCheckbox || !statusText) {
                return;
            }
    
            const enabled = schedulerCheckbox.checked;
            if (enabled) {
                const activeSchedule = getActiveSchedule();
                if (activeSchedule) {
                    statusText.textContent = `‚úÖ ENCENDIDO (hasta ${activeSchedule.endTime})`;
                    statusText.style.color = '#28a745';
                } else {
                    statusText.textContent = `‚è∏Ô∏è APAGADO (esperando horario)`;
                    statusText.style.color = '#dc3545';
                }
            } else {
                statusText.textContent = 'Desactivado';
                statusText.style.color = '#6c757d';
            }
        }
        
        function getActiveSchedule() {
            const now = new Date();
            const currentDay = now.getDay();
            const currentTime = now.getHours() * 60 + now.getMinutes();

            for (const schedule of schedules) {
                if (!schedule.enabled) continue;
                
                const [startH, startM] = schedule.startTime.split(':').map(Number);
                const [endH, endM] = schedule.endTime.split(':').map(Number);
                const startMinutes = startH * 60 + startM;
                const endMinutes = endH * 60 + endM;

                const isOvernight = endMinutes < startMinutes;

                if (!isOvernight) {
                    // --- Horario Normal ---
                    // Encendido desde startTime (inclusive) hasta endTime (exclusive)
                    // Ejemplo: 18:00-23:00 significa encendido de 18:00 a 22:59, apaga a las 23:00
                    if (schedule.days.includes(currentDay) && currentTime >= startMinutes && currentTime < endMinutes) {
                        return schedule;
                    }
                } else {
                    // --- Horario Overnight ---
                    const prevDay = (currentDay === 0) ? 6 : currentDay - 1;

                    // 1. ¬øEst√° activo *despu√©s* de medianoche? (p.ej. 02:00)
                    // Desde 00:00 (inclusive) hasta endTime (exclusive)
                    if (schedule.days.includes(prevDay) && currentTime >= 0 && currentTime < endMinutes) {
                        return schedule;
                    }
                    // 2. ¬øEst√° activo *antes* de medianoche? (p.ej. 22:00)
                    // Desde startTime (inclusive) hasta 23:59 (inclusive)
                    if (schedule.days.includes(currentDay) && currentTime >= startMinutes && currentTime <= 1439) {
                        return schedule;
                    }
                }
            }
            
            return null;
        }
        
        async function checkSchedules() {
            // VALIDAR PRIMERO SI HAY CONEXI√ìN
            if (!mqttClient || !mqttClient.connected) {
                addDebugLog('‚ö†Ô∏è No hay conexi√≥n MQTT para verificar horarios', 'error');
                return;
            }
    
            // VALIDAR SI EL SCHEDULER EST√Å HABILITADO
            if (!document.getElementById('schedulerEnabled') || !document.getElementById('schedulerEnabled').checked) {
                return;
            }

            const activeSchedule = getActiveSchedule();
            const shouldBeOn = activeSchedule !== null;

            // Al inicio, sincronizar lastScheduleState sin enviar comandos
            if (lastScheduleState === null) {
                lastScheduleState = shouldBeOn;
                addDebugLog(`üîÑ Estado inicial del scheduler: ${shouldBeOn ? 'Horario activo' : 'Fuera de horario'} (sin enviar comandos)`, 'info');
                return; // No enviar comandos al cargar la p√°gina
            }

            if (lastScheduleState !== shouldBeOn) {
                lastScheduleState = shouldBeOn;
                if (shouldBeOn) {
                    addDebugLog('‚è∞ Horario activo - Encendiendo LEDs', 'success');
                    showStatus('‚è∞ Horario: Encendiendo LEDs');
    
                    // Comando simple para encender
                    await sendMQTTCommand({
                        "on": true,
                        "bri": currentBrightness
                    });
                } else {
                    addDebugLog('‚è∞ Fuera de horario - Apagando LEDs', 'info');
                    showStatus('‚è∞ Horario: Apagando LEDs');
    
                    // Comando simple para apagar
                    await sendMQTTCommand({
                        "on": false
                    });
                    updateAllLEDsVisual('#000000');
                }
            }

            updateSchedulerStatus();
        }

        async function testScheduleOff() {
            addDebugLog('üß™ Test: Enviando comando OFF completo', 'info');
            const offCommand = {
                "on": false,
                "bri": 0,
                "seg": [{
                    "id": 0,
                    "on": false,
                    "bri": 0,
                    "fx": 0,
                    "col": [[0,0,0], [0,0,0], [0,0,0]]
                }],
                "transition": 0
             };
    
            const success = await sendMQTTCommand(offCommand);
            if (success) {
                updateAllLEDsVisual('#000000');
                showStatus('‚úÖ Comando OFF de prueba enviado');
            }
        }
        
        // =====================================================
        // DEBUG LOG
        // =====================================================
        
        function addDebugLog(message, type = 'info') {
            const logDiv = document.getElementById('debugLog');
            const entry = document.createElement('div');
            entry.className = type;
            const timestamp = new Date().toLocaleTimeString();
            entry.textContent = `[${timestamp}] ${message}`;
            logDiv.appendChild(entry);
            logDiv.scrollTop = logDiv.scrollHeight;
            while (logDiv.children.length > 50) {
                logDiv.removeChild(logDiv.firstChild);
            }
        }
        
        // =====================================================
        // CONEXI√ìN MQTT (mantener las funciones existentes)
        // =====================================================
        
        function initMQTT() {
            addDebugLog('üîå Iniciando conexi√≥n a Mosquitto...', 'info');
            addDebugLog(`üì° Broker: ${MQTT_CONFIG.broker}`, 'info');
            
            const options = {
                clientId: 'web-tree-' + Math.random().toString(16).substr(2, 8),
                clean: true,
                reconnectPeriod: 5000,
                connectTimeout: 30000,
                protocol: 'wss',
                 protocolVersion: 4,
                rejectUnauthorized: true,
                keepalive: 60
            };
            if (MQTT_CONFIG.username) {
                options.username = MQTT_CONFIG.username;
                options.password = MQTT_CONFIG.password;
            }
            
            try {
                mqttClient = mqtt.connect(MQTT_CONFIG.broker, options);
                mqttClient.on('connect', () => {
                    addDebugLog('‚úÖ Conectado exitosamente a Mosquitto!', 'success');
                    document.getElementById('connectionStatus').className = 'connection-status connected';
                    document.getElementById('connectionStatus').textContent = '‚úÖ Conectado';
                    
                     mqttClient.subscribe('wled/tree/#', (err) => {
                        if (!err) {
                            addDebugLog('üì° Suscrito a topics WLED', 'success');
                            addDebugLog('‚è≥ Esperando estado de WLED...', 'info');

                            // Publicar horarios locales despu√©s de suscribirse
                            // Si hay horarios retenidos en MQTT, llegar√°n primero y sobrescribir√°n estos
                            setTimeout(() => {
                                if (schedules.length > 0 || document.getElementById('schedulerEnabled').checked) {
                                    const schedulesData = {
                                        schedules: schedules,
                                        enabled: document.getElementById('schedulerEnabled').checked,
                                        timestamp: Date.now()
                                    };
                                    mqttClient.publish('wled/tree/schedules', JSON.stringify(schedulesData), { retain: true });
                                    addDebugLog('üì§ Horarios locales publicados al conectar', 'info');
                                }
                            }, 500);
                        } else {
                            addDebugLog('‚ö†Ô∏è Error al suscribirse: ' + err.message, 'error');
                        }
                    });
                });
                mqttClient.on('error', (err) => {
                    addDebugLog('‚ùå Error MQTT: ' + err.message, 'error');
                    document.getElementById('connectionStatus').className = 'connection-status disconnected';
                    document.getElementById('connectionStatus').textContent = '‚ùå Error de conexi√≥n';
                });
                mqttClient.on('reconnect', () => {
                    addDebugLog('üîÑ Intentando reconectar...', 'info');
                    document.getElementById('connectionStatus').className = 'connection-status connecting';
                    document.getElementById('connectionStatus').textContent = 'üîÑ Reconectando...';
                });
                mqttClient.on('offline', () => {
                    addDebugLog('‚ö†Ô∏è Cliente MQTT offline', 'error');
                    document.getElementById('connectionStatus').className = 'connection-status disconnected';
                    document.getElementById('connectionStatus').textContent = '‚ö†Ô∏è Desconectado';
                });

                // INICIO: Soluci√≥n #5 - Procesar mensajes de estado de WLED
                mqttClient.on('message', (topic, message) => {
                    const payloadStr = message.toString();

                    // Procesar mensajes de brillo para sincronizaci√≥n entre dispositivos
                    if (topic === 'wled/tree/brightness') {
                        const brightness = parseInt(payloadStr);
                        if (!isNaN(brightness) && brightness >= 0 && brightness <= 255) {
                            // Solo actualizar si es diferente del actual (evitar loops)
                            if (Math.abs(brightness - currentBrightness) > 2) {
                                currentBrightness = brightness;
                                document.getElementById('brightness').value = brightness;
                                updateBrightnessLabel(brightness);
                                localStorage.setItem('lastBrightness', brightness.toString());
                                addDebugLog(`üí° Brillo sincronizado desde otro dispositivo: ${brightness}`, 'success');
                            }
                        }
                        return;
                    }

                    // Procesar mensajes de horarios para sincronizaci√≥n entre dispositivos
                    if (topic === 'wled/tree/schedules') {
                        try {
                            const data = JSON.parse(payloadStr);
                            if (data.schedules && Array.isArray(data.schedules)) {
                                // Evitar loop si es nuestro propio mensaje (comparar timestamp reciente)
                                const timeDiff = Date.now() - (data.timestamp || 0);
                                if (timeDiff > 1000) { // Solo aplicar si tiene m√°s de 1 segundo
                                    schedules = data.schedules;
                                    localStorage.setItem('wledSchedules', JSON.stringify(schedules));

                                    if (typeof data.enabled !== 'undefined') {
                                        document.getElementById('schedulerEnabled').checked = data.enabled;
                                        localStorage.setItem('schedulerEnabled', data.enabled.toString());
                                    }

                                    renderScheduleGrid();
                                    addDebugLog('üì• Horarios sincronizados desde otro dispositivo', 'success');
                                }
                            }
                        } catch (e) {
                            addDebugLog('‚ùå Error al procesar horarios: ' + e.message, 'error');
                        }
                        return;
                    }

                    // Procesar mensajes de estado de WLED (v, state, o api con JSON de estado)
                    if (topic === 'wled/tree/v' || topic === 'wled/tree/state' || topic === 'wled/tree/api') {
                        const trimmedPayload = payloadStr.trim();

                        // Mostrar preview del contenido (incluso si est√° vac√≠o)
                        if (trimmedPayload.length === 0) {
                            addDebugLog(`üì® ${topic}: (vac√≠o)`, 'info');
                            return;
                        }

                        const preview = trimmedPayload.substring(0, 80);
                        addDebugLog(`üì® ${topic}: ${preview}${trimmedPayload.length > 80 ? '...' : ''}`, 'success');

                        // Detectar si es XML
                        if (trimmedPayload.startsWith('<?xml') || trimmedPayload.startsWith('<')) {
                            const state = parseWLEDXML(trimmedPayload);
                            if (state) {
                                handleWLEDState(state);
                            }
                            return;
                        }

                        // Validar que el payload sea JSON v√°lido antes de parsear
                        if (!trimmedPayload.startsWith('{') && !trimmedPayload.startsWith('[')) {
                            addDebugLog(`‚ö†Ô∏è ${topic}: Formato desconocido`, 'error');
                            return;
                        }

                        try {
                            const data = JSON.parse(payloadStr);

                            // Solo procesar si es un estado COMPLETO (no comandos parciales)
                            // Un estado completo debe tener al menos 'state' o tanto 'on' como 'seg'
                            const isCompleteState = data.state || (data.seg && data.on !== undefined);

                            if (isCompleteState) {
                                addDebugLog(`üìä Estado completo detectado en ${topic}`, 'info');
                                const state = data.state || data;
                                handleWLEDState(state);
                            } else {
                                addDebugLog(`‚è© Comando parcial ignorado en ${topic} (solo tiene: ${Object.keys(data).join(',')})`, 'info');
                            }
                        } catch (e) {
                            // Ignorar errores de JSON parse silenciosamente
                        }
                    }
                    // Ignorar silenciosamente otros topics (g, c, status, etc.)
                });
                // FIN: Soluci√≥n #5

            } catch (error) {
                addDebugLog('‚ùå Error cr√≠tico al inicializar: ' + error.message, 'error');
            }
        }
        
        function reconnectMQTT() {
            if (mqttClient) {
                addDebugLog('üîÑ Desconectando cliente anterior...', 'info');
                mqttClient.end(true);
                mqttClient = null;
            }
            setTimeout(() => {
                initMQTT();
            }, 500);
        }

        // Funci√≥n para parsear XML de WLED y convertirlo a formato JSON (actualizado)
        function parseWLEDXML(xmlString) {
            try {
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(xmlString, "text/xml");

                // Verificar si hay errores de parseo
                const parseError = xmlDoc.querySelector('parsererror');
                if (parseError) {
                    throw new Error('Error al parsear XML');
                }

                const vs = xmlDoc.querySelector('vs');
                if (!vs) {
                    throw new Error('No se encontr√≥ elemento <vs> en XML');
                }

                // Extraer brillo (ac = actual brightness)
                const acElement = vs.querySelector('ac');
                const brightness = acElement ? parseInt(acElement.textContent) : 128;

                // Extraer colores primarios (cl = color)
                const clElements = vs.querySelectorAll('cl');
                const colors = Array.from(clElements).map(el => parseInt(el.textContent));

                // Extraer efecto (fx)
                const fxElement = vs.querySelector('fx');
                const fx = fxElement ? parseInt(fxElement.textContent) : 0;

                // Extraer paleta (fp)
                const fpElement = vs.querySelector('fp');
                const pal = fpElement ? parseInt(fpElement.textContent) : 0;

                // Determinar si est√° encendido (si hay brillo o si el XML lo indica)
                const isOn = brightness > 0;

                // Crear objeto compatible con handleWLEDState
                const state = {
                    on: isOn,
                    bri: brightness,
                    seg: [{
                        col: [colors.length >= 3 ? colors.slice(0, 3) : [255, 255, 255]],
                        fx: fx,
                        pal: pal
                    }]
                };

                addDebugLog(`‚úÖ Estado: ${isOn ? 'ON' : 'OFF'}, Brillo: ${brightness}, FX: ${fx}, Pal: ${pal}`, 'success');

                return state;
            } catch (e) {
                addDebugLog('‚ùå Error al parsear XML de WLED: ' + e.message, 'error');
                return null;
            }
        }

        // INICIO: Soluci√≥n #5 - Nueva funci√≥n para manejar el estado de WLED
        function handleWLEDState(state) {
            if (!state) {
                addDebugLog('‚ö†Ô∏è Estado WLED recibido pero vac√≠o', 'error');
                return;
            }

            // Si los LEDs no est√°n listos, guardar el estado para aplicarlo despu√©s
            if (!ledsReady || ledMeshes.length === 0) {
                addDebugLog('‚è≥ LEDs no listos, guardando estado para aplicar despu√©s...', 'info');
                pendingWLEDState = state;
                return;
            }

            // Protecci√≥n contra loops: evitar procesar el mismo estado m√∫ltiples veces
            const now = Date.now();
            const fx = state.seg?.[0]?.fx;
            const pal = state.seg?.[0]?.pal;
            const bri = state.bri;
            const stateSignature = `${fx}-${pal}-${bri}`;

            // Si es el mismo estado que acabamos de procesar hace menos de 800ms, ignorarlo
            if (stateSignature === lastProcessedState && (now - lastProcessedTime) < 800) {
                return; // Ignorar para evitar loop
            }

            lastProcessedState = stateSignature;
            lastProcessedTime = now;

            // 1. Actualizar Brillo
            if (typeof state.bri !== 'undefined') {
                const brightness = state.bri;
                document.getElementById('brightness').value = brightness;
                updateBrightnessLabel(brightness);
                currentBrightness = brightness;

                // Guardar el brillo en localStorage para persistencia
                localStorage.setItem('lastBrightness', brightness.toString());

                // Publicar brillo en MQTT para sincronizar entre dispositivos
                if (mqttClient && mqttClient.connected) {
                    mqttClient.publish('wled/tree/brightness', brightness.toString(), { retain: true });
                }
            }

            // 2. Actualizar Estado (On/Off)
            if (typeof state.on === 'undefined' || !state.on) {
                addDebugLog('‚ö´ Apagado', 'info');
                updateAllLEDsVisual('#000000');
                return; // Si est√° apagado, no procesar colores
            }

            // 3. Actualizar Colores y Efectos (basado en el primer segmento)
            if (state.seg && state.seg[0]) {
                const segment = state.seg[0];
                const fx = segment.fx;
                const pal = segment.pal;
                const col = segment.col[0] || [255, 0, 0]; // Color primario, con fallback

                // Sincronizar efecto y paleta actuales
                currentEffectId = fx;
                currentPaletteId = pal || 0;

                const hexColor = rgbToHex(col[0], col[1], col[2]);

                // Actualizar el picker de color de la UI
                selectedColor = hexColor;
                document.getElementById('ledColor').value = hexColor;

                // Detener cualquier animaci√≥n local
                stopAllAnimations();

                if (fx === 0) {
                    // --- Efecto S√≥lido ---
                    addDebugLog(`üîÑ Sincronizando: Color S√≥lido ${hexColor}`, 'info');
                    updateAllLEDsVisual(hexColor);
                } else {
                    // --- Efecto Animado ---
                    addDebugLog(`üîÑ Sincronizando: Efecto ${fx}, Paleta ${pal || 'default'}`, 'info');
                    // Mostrar solo el color base - WLED maneja la animaci√≥n real
                    updateAllLEDsVisual(hexColor);
                }
            }
        }
        // FIN: Soluci√≥n #5
        
        // =====================================================
        // ENV√çO DE COMANDOS MQTT
        // =====================================================
        
        async function sendMQTTCommand(payload) {
            if (!mqttClient || !mqttClient.connected) {
                addDebugLog('‚ùå No hay conexi√≥n MQTT', 'error');
                showStatus('‚ùå No conectado a MQTT', true);
                return false;
            }
            
            const payloadStr = JSON.stringify(payload);
            addDebugLog(`üì§ Enviando comando: ${payloadStr.substring(0, 80)}...`, 'info');
            
            try {
                mqttClient.publish(MQTT_CONFIG.topic, payloadStr, { qos: 1, retain: false }, (err) => {
                    if (err) {
                        addDebugLog('‚ùå Error al publicar: ' + err.message, 'error');
                     } else {
                        addDebugLog('‚úÖ Comando enviado correctamente', 'success');
                    }
                });
                return true;
            } catch (error) {
                addDebugLog('‚ùå Excepci√≥n al publicar: ' + error.message, 'error');
                return false;
            }
        }
        
        async function sendTestMessage() {
            const testPayload = {
                "test": true,
                "timestamp": new Date().toISOString(),
                "message": "Test desde interfaz web"
             };
            
            addDebugLog('üß™ Enviando mensaje de prueba...', 'info');
            const success = await sendMQTTCommand(testPayload);
            
            if (success) {
                showStatus('‚úÖ Mensaje de prueba enviado');
            }
        }
        
        // =====================================================
        // FUNCIONES DE CONTROL (mantener todas las existentes)
        // =====================================================
        
        async function resetWLED() {
            stopAllAnimations();
            addDebugLog('üî¥ Apagando LEDs...', 'info');
            
            await sendMQTTCommand({
                "on": false,
                "seg": [{
                    "fx": 0,
                    "sx": 0,
                    "ix": 0,
                    "pal": 0,
                    "col": [[0,0,0]]
                }]
            });
            updateAllLEDsVisual('#000000');
            showStatus('‚úì LEDs apagados');
        }
        
        function applyColorOrder(r, g, b) {
            switch(COLOR_ORDER) {
                case 'RGB':
                    return [r, g, b];
                case 'GRB':
                    return [g, r, b];
                case 'BGR':
                    return [b, g, r];
                case 'RBG':
                    return [r, b, g];
                case 'GBR':
                    return [g, b, r];
                case 'BRG':
                    return [b, r, g];
                default:
                    return [r, g, b];
            }
        }
        
        // INICIO: Funciones de Diagn√≥stico Eliminadas
        // testColorDirect, cycleColorTest, y testIndividualLEDs han sido eliminadas.
        // FIN: Funciones de Diagn√≥stico Eliminadas
        
        // CONTROL DE LEDS
        function activatePaintMode() {
            paintMode = !paintMode;
            const btn = document.getElementById('paintBtn');
            const palette = document.getElementById('colorPalette');
            
            if (paintMode) {
                btn.classList.add('active');
                btn.textContent = 'Paint Mode: ON';
                palette.style.display = 'grid';
                showStatus('üé® Paint Mode activado');
                addDebugLog('üé® Paint Mode activado', 'info');
            } else {
                btn.classList.remove('active');
                btn.textContent = 'Activar Paint Mode';
                palette.style.display = 'none';
                showStatus('Paint Mode desactivado');
                addDebugLog('Paint Mode desactivado', 'info');
            }
        }
        
        function updateSelectedColor() {
            selectedColor = document.getElementById('ledColor').value;
            addDebugLog(`üé® Color seleccionado: ${selectedColor}`, 'info');
        }
        
        function selectPaletteColor(color) {
            selectedColor = color;
            document.getElementById('ledColor').value = color;
            
            document.querySelectorAll('.palette-color').forEach(el => {
                el.classList.remove('selected');
            });
            event.target.classList.add('selected');
        }
        
        async function updateLEDColor(index, color) {
            if (index < 0 || index >= totalLeds) return;
            ledColors[index] = color;
            updateLEDVisual(index, color, true);
            
            const rgb = hexToRgb(color);
            if (!rgb) return;
            
            const orderedRgb = applyColorOrder(rgb.r, rgb.g, rgb.b);
            await sendMQTTCommand({
                "on": true,
                "seg": [{
                    "fx": 0,
                    "i": [index, orderedRgb]
                }]
             });
        }
        
        function updateLEDVisual(index, color, needsUpdate = true) {
            if (index < 0 || index >= totalLeds || !ledMeshes[index]) return;
            const mesh = ledMeshes[index];
            mesh.material.color.set(color);
            
            if (needsUpdate) {
                mesh.material.needsUpdate = true;
            }
        }
        
        function updateAllLEDsVisual(color) {
            for (let i = 0; i < totalLeds; i++) {
                ledColors[i] = color;
                updateLEDVisual(i, color, false);
            }
            
            ledMeshes.forEach(mesh => {
                mesh.material.needsUpdate = true;
            });
        }
        
        // DISE√ëOS EST√ÅTICOS (mantener todas las funciones existentes)
        function setStaticDesign(designName) {
            stopAllAnimations();
            currentEffect = designName;
            
            addDebugLog(`üé® Aplicando dise√±o est√°tico: ${designName}`, 'info');
            
            document.querySelectorAll('.effect-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            if (event && event.target) {
                event.target.classList.add('active');
            }
            
            switch(designName) {
                case 'OFF':
                    applyOFFDesign();
                    break;
                case 'Solid':
                    applySolidDesign();
                    break;
                case 'Rainbow':
                    applyRainbowDesign();
                    break;
                case 'Warm':
                    applyWarmDesign();
                    break;
                case 'Cold':
                    applyColdDesign();
                    break;
                case 'Purple Rain':
                    applyPurpleRainDesign();
                    break;
                case 'Dominican':
                    applyDominicanDesign();
                    break;
            }
        }

        async function applyOFFDesign() {
            updateAllLEDsVisual('#000000');
            await sendMQTTCommand({ "on": false });
            showStatus('‚úì LEDs apagados');
        }

        async function applySolidDesign() {
            updateAllLEDsVisual(selectedColor);
            const rgb = hexToRgb(selectedColor);
            
            await sendMQTTCommand({
                "on": true,
                "bri": currentBrightness,
                "seg": [{
                    "id": 0,
                    "fx": 0,
                    "col": [applyColorOrder(rgb.r, rgb.g, rgb.b)]
                }]
            });
            showStatus(`‚úì Solid ${selectedColor}`);
        }

        async function applyRainbowDesign(sendToWLED = true) {
            addDebugLog('üåà Aplicando Rainbow', 'info');
            for (let i = 0; i < totalLeds; i++) {
                const hue = (i * 360 / totalLeds) % 360;
                const color = hslToRgb(hue, 100, 50);
                const hexColor = rgbToHex(color.r, color.g, color.b);
                updateLEDVisual(i, hexColor, false);
            }
            ledMeshes.forEach(mesh => mesh.material.needsUpdate = true);

            if (sendToWLED) {
                await sendMQTTCommand({
                    "on": true,
                    "bri": currentBrightness,
                    "seg": [{
                        "id": 0,
                        "fx": 9,
                        "pal": 11
                    }]
                });
            }
            showStatus('‚úì Rainbow aplicado');
        }

        async function applyWarmDesign() {
            const warmColor = '#ffe4b5';
            updateAllLEDsVisual(warmColor);
            
            const rgb = hexToRgb(warmColor);
            
            await sendMQTTCommand({
                "on": true,
                "bri": currentBrightness,
                "seg": [{
                    "id": 0,
                    "fx": 0,
                     "col": [applyColorOrder(rgb.r, rgb.g, rgb.b)]
                }]
            });
            showStatus('‚úì Warm aplicado');
        }

        async function applyColdDesign() {
            addDebugLog('‚ùÑÔ∏è Aplicando Cold', 'info');
            const coldColors = ['#0066ff', '#00ccff', '#6600ff', '#00ffff', '#3366ff'];
            for (let i = 0; i < totalLeds; i++) {
                const colorHex = coldColors[i % coldColors.length];
                updateLEDVisual(i, colorHex, false);
            }
            ledMeshes.forEach(mesh => mesh.material.needsUpdate = true);
            await sendMQTTCommand({
                "on": true,
                "bri": currentBrightness,
                "seg": [{
                    "id": 0,
                    "fx": 67,
                    "pal": 9
                }]
            });
            showStatus('‚úì Cold aplicado');
        }

        async function applyPurpleRainDesign() {
            const purpleColor = '#8b00ff';
            updateAllLEDsVisual(purpleColor);
            
            const rgb = hexToRgb(purpleColor);
            
            await sendMQTTCommand({
                "on": true,
                "bri": currentBrightness,
                "seg": [{
                    "id": 0,
                    "fx": 0,
                     "col": [applyColorOrder(rgb.r, rgb.g, rgb.b)]
                }]
            });
            showStatus('‚úì Purple Rain aplicado');
        }

        async function applyDominicanDesign() {
            addDebugLog('üá©üá¥ Aplicando Dominican', 'info');
            const third = Math.floor(totalLeds / 3);
            
            for (let i = 0; i < totalLeds; i++) {
                let colorHex;
                if (i < third) {
                    colorHex = '#0000ff';
                } else if (i < third * 2) {
                    colorHex = '#ffffff';
                } else {
                    colorHex = '#ff0000';
                }
                updateLEDVisual(i, colorHex, false);
            }
            ledMeshes.forEach(mesh => mesh.material.needsUpdate = true);
            await sendMQTTCommand({
                "on": true,
                "bri": currentBrightness,
                "seg": [{
                    "id": 0,
                    "fx": 2,
                    "pal": 255
                }]
            });
            showStatus('‚úì Dominican aplicado üá©üá¥');
        }
        
        // EFECTOS ANIMADOS (mantener todas las funciones existentes)
        function runAnimatedEffect(effectName, sendToWLED = true) {
            if (effectAnimationInterval) {
                clearInterval(effectAnimationInterval);
            }
            if (localAnimationInterval) {
                clearInterval(localAnimationInterval);
            }

            currentLocalAnimation = effectName;
            showStatus(`üîÑ Animaci√≥n "${effectName}" iniciada`);
            addDebugLog(`üé¨ Iniciando animaci√≥n: ${effectName}`, 'info');

            // Mapeo de efectos a sus n√∫meros de FX, paletas y funciones de animaci√≥n
            const effectMap = {
                'Fire': { fx: 45, pal: 35, animate: animateFire }, // Fire Flicker con Fire palette
                'Chase': { fx: 28, animate: animateChase },
                'Twinkle': { fx: 17, animate: animateTwinkle },
                'Sparkle': { fx: 20, animate: animateSparkle },
                'Ripple': { fx: 79, animate: animateRipple },
                'Blink': { fx: 1, animate: animateBlink },
                'Scan': { fx: 10, animate: animateScan },
                'Waves': { fx: 67, animate: animateWaves },
                'Fairy': { fx: 49, animate: animateFairy },
                'Flow': { fx: 110, animate: animateFlow }
            };

            const effect = effectMap[effectName];
            if (effect) {
                effect.animate();
                if (sendToWLED) {
                    sendWLEDEffect(effect.fx, effect.pal || null);
                }
            }
        }

        async function sendWLEDEffect(fxNumber, paletteNumber = null) {
            const rgb = hexToRgb(selectedColor);
            const colorArray = applyColorOrder(rgb.r, rgb.g, rgb.b);

            const segmentConfig = {
                "id": 0,
                "fx": fxNumber,
                "col": [colorArray, [0, 0, 0], [0, 0, 0]]
            };

            // Add palette if specified
            if (paletteNumber !== null) {
                segmentConfig.pal = paletteNumber;
            }

            await sendMQTTCommand({
                "on": true,
                "bri": currentBrightness,
                "mainseg": 0,
                "seg": [segmentConfig]
            });
        }

        // Apply a color palette - mantiene el efecto actual y solo cambia la paleta
        async function setPalette(paletteId) {
            addDebugLog(`üé® Cambiando palette a: ${paletteId} (manteniendo efecto ${currentEffectId})`, 'info');

            // Guardar la paleta actual
            currentPaletteId = paletteId;

            // Definir colores base para paletas especiales
            const paletteBaseColors = {
                2: '#9B30FF',      // Purple Rain - morado vibrante
                6: '#FF1493',      // Party - magenta/rosa vibrante (rainbow sin verde)
                7: '#87CEEB',      // Cloud - azul cielo suave
                8: '#FF4500',      // Lava - naranja lava
                9: '#006994',      // Ocean - azul oc√©ano
                10: '#9ACD32',     // Forest - verde amarillento (yellow-green)
                11: '#FF0000',     // Rainbow - rojo inicial
                13: '#FF6347',     // Sunset - naranja/rojo atardecer
                20: '#FFB6C1',     // Pastel - rosa pastel suave
                26: '#20B2AA',     // Beach - teal/turquesa
                35: '#FF4500',     // Fire - naranja/rojo fuego
                48: '#E74C3C',     // C9 (Christmas) - rojo navide√±o
                50: '#00FF7F',     // Aurora - verde aurora boreal
                255: '#0038A8'     // Dominican - azul de la bandera
            };

            // Si la paleta tiene un color base definido, usarlo
            let colorToUse = selectedColor;
            if (paletteBaseColors[paletteId]) {
                colorToUse = paletteBaseColors[paletteId];
                selectedColor = colorToUse;
                document.getElementById('ledColor').value = colorToUse;
                addDebugLog(`üé® Color base establecido a ${colorToUse} para palette ${paletteId}`, 'info');
            }

            const rgb = hexToRgb(colorToUse);
            const colorArray = applyColorOrder(rgb.r, rgb.g, rgb.b);

            // Aplicar la paleta con el efecto actual
            await sendMQTTCommand({
                "on": true,
                "bri": currentBrightness,
                "mainseg": 0,
                "seg": [{
                    "id": 0,
                    "fx": currentEffectId,
                    "pal": paletteId,
                    "col": [colorArray, [0, 0, 0], [0, 0, 0]]
                }]
            });

            // Si est√° en modo Solid (fx: 0), actualizar visualizaci√≥n inmediatamente
            if (currentEffectId === 0) {
                updateAllLEDsVisual(colorToUse);
            }

            showStatus(`‚úì Palette ${paletteId} aplicada con efecto ${currentEffectId}`);
        }

        // Run an effect mode - usa la paleta actual
        async function runEffect(fxId) {
            addDebugLog(`‚ö° Aplicando efecto: fx=${fxId} con palette=${currentPaletteId}`, 'info');

            // Guardar el efecto actual
            currentEffectId = fxId;

            // Stop any local animations
            if (effectAnimationInterval) clearInterval(effectAnimationInterval);
            if (localAnimationInterval) clearInterval(localAnimationInterval);

            const rgb = hexToRgb(selectedColor);
            const colorArray = applyColorOrder(rgb.r, rgb.g, rgb.b);

            // Aplicar el efecto con la paleta actual
            await sendMQTTCommand({
                "on": true,
                "bri": currentBrightness,
                "mainseg": 0,
                "seg": [{
                    "id": 0,
                    "fx": fxId,
                    "pal": currentPaletteId,
                    "col": [colorArray, [0, 0, 0], [0, 0, 0]]
                }]
            });

            // Mostrar color base de la paleta en la visualizaci√≥n
            // Las animaciones reales las maneja WLED en el hardware
            // La visualizaci√≥n local solo muestra el color base para no confundir
            if (fxId === 0) {
                // Solid: mostrar el color seleccionado
                updateAllLEDsVisual(selectedColor);
            } else {
                // Efectos animados: mostrar color base de la paleta
                // WLED maneja la animaci√≥n real en el hardware
                updateAllLEDsVisual(selectedColor);
            }

            showStatus(`‚úì Effect ${fxId} aplicado con palette ${currentPaletteId}`);
        }

        // Helper to get effect name from ID
        function getEffectName(fxId) {
            const effectNames = {
                1: 'Blink', 9: 'Rainbow', 10: 'Scan', 17: 'Twinkle', 20: 'Sparkle',
                28: 'Chase', 45: 'Fire', 67: 'Waves', 79: 'Ripple', 110: 'Flow'
            };
            return effectNames[fxId] || null;
        }

        // Helper to get animation function from ID
        function getAnimationFunction(fxId) {
            const animations = {
                1: animateBlink, 10: animateScan, 17: animateTwinkle, 20: animateSparkle,
                28: animateChase, 45: animateFire, 67: animateWaves, 79: animateRipple, 110: animateFlow
            };
            return animations[fxId] || null;
        }

        function animateFire() {
            effectAnimationInterval = setInterval(() => {
                for (let i = 0; i < totalLeds; i++) {
                    const intensity = Math.random();
                    const r = 255;
                     const g = Math.floor(intensity * 150);
                    const b = 0;
                    const hexColor = rgbToHex(r, g, b);
                    updateLEDVisual(i, hexColor, false);
                 }
                ledMeshes.forEach(mesh => mesh.material.needsUpdate = true);
            }, 100);
        }

        function animateChase() {
            let pos = 0;
            effectAnimationInterval = setInterval(() => {
                for (let i = 0; i < totalLeds; i++) {
                    if (i % 10 === pos) {
                        updateLEDVisual(i, selectedColor, false);
                     } else {
                        updateLEDVisual(i, '#000000', false);
                    }
                }
                ledMeshes.forEach(mesh => mesh.material.needsUpdate = true);
                 pos = (pos + 1) % 10;
            }, 100);
        }

        function animateTwinkle() {
            effectAnimationInterval = setInterval(() => {
                for (let i = 0; i < totalLeds; i++) {
                    if (Math.random() > 0.95) {
                        updateLEDVisual(i, '#ffffff', false);
                    } else {
                        updateLEDVisual(i, selectedColor, false);
                    }
                }
                 ledMeshes.forEach(mesh => mesh.material.needsUpdate = true);
            }, 200);
        }

        function animateSparkle() {
            effectAnimationInterval = setInterval(() => {
                for (let i = 0; i < totalLeds; i++) {
                    updateLEDVisual(i, selectedColor, false);
                }
                 const sparkleIndex = Math.floor(Math.random() * totalLeds);
                updateLEDVisual(sparkleIndex, '#ffffff', false);
                ledMeshes.forEach(mesh => mesh.material.needsUpdate = true);
            }, 100);
        }

        function animateRipple() {
            let offset = 0;
            effectAnimationInterval = setInterval(() => {
                for (let i = 0; i < totalLeds; i++) {
                    const distance = Math.abs(i - totalLeds/2);
                    const wave = Math.sin((distance + offset) * 0.3) * 0.5 + 0.5;
                     const rgb = hexToRgb(selectedColor);
                    const hexColor = rgbToHex(
                        Math.floor(rgb.r * wave),
                        Math.floor(rgb.g * wave),
                         Math.floor(rgb.b * wave)
                    );
                    updateLEDVisual(i, hexColor, false);
                }
                ledMeshes.forEach(mesh => mesh.material.needsUpdate = true);
                 offset += 1;
            }, 80);
        }

        function animateBlink() {
            let on = true;
            localAnimationInterval = setInterval(() => {
                if (on) {
                    updateAllLEDsVisual(selectedColor);
                } else {
                     updateAllLEDsVisual('#000000');
                }
                on = !on;
            }, 500);
        }
        
        function animateScan() {
            let currentLed = 0;
            localAnimationInterval = setInterval(() => {
                for (let i = 0; i < totalLeds; i++) {
                    if (i === currentLed) {
                        updateLEDVisual(i, selectedColor, false);
                    } else {
                        updateLEDVisual(i, '#000000', false);
                    }
                }
                ledMeshes.forEach(mesh => mesh.material.needsUpdate = true);
                
                 currentLed = (currentLed + 1) % totalLeds;
            }, 50);
        }
        
        function animateWaves() {
            let offset = 0;
            localAnimationInterval = setInterval(() => {
                const rgb = hexToRgb(selectedColor);
                
                for (let i = 0; i < totalLeds; i++) {
                    const wave = Math.sin((i + offset) * 0.2) * 0.5 + 0.5;
                     const waveColor = rgbToHex(
                        Math.floor(rgb.r * wave),
                        Math.floor(rgb.g * wave),
                        Math.floor(rgb.b * wave)
                     );
                    updateLEDVisual(i, waveColor, false);
                }
                ledMeshes.forEach(mesh => mesh.material.needsUpdate = true);
                
                 offset += 1;
            }, 100);
        }
        
        function animateFairy() {
            localAnimationInterval = setInterval(() => {
                for (let i = 0; i < totalLeds; i++) {
                    if (Math.random() > 0.7) {
                         updateLEDVisual(i, selectedColor, false);
                    } else {
                        updateLEDVisual(i, '#000000', false);
                    }
                }
                 ledMeshes.forEach(mesh => mesh.material.needsUpdate = true);
            }, 200);
        }
        
        function animateFlow() {
            let hue = 0;
            localAnimationInterval = setInterval(() => {
                for (let i = 0; i < totalLeds; i++) {
                    const ledHue = (hue + (i * 360 / totalLeds)) % 360;
                    const color = hslToRgb(ledHue, 100, 50);
                     const hexColor = rgbToHex(color.r, color.g, color.b);
                    updateLEDVisual(i, hexColor, false);
                }
                ledMeshes.forEach(mesh => mesh.material.needsUpdate = true);
                
                
                hue = (hue + 5) % 360;
            }, 100);
        }

        function stopAllAnimations() {
            if (effectAnimationInterval) {
                clearInterval(effectAnimationInterval);
                effectAnimationInterval = null;
            }
            if (localAnimationInterval) {
                clearInterval(localAnimationInterval);
                localAnimationInterval = null;
            }
            currentLocalAnimation = null;
            addDebugLog('‚èπ Animaci√≥n detenida', 'info');
            // No mostrar status aqu√≠, es muy ruidoso
        }
        
        // BRILLO
        let brightnessTimeout = null;
        function setBrightness(value) {
            currentBrightness = parseInt(value);
            updateBrightnessLabel(value);

            // Guardar brillo en localStorage para persistencia local
            localStorage.setItem('lastBrightness', currentBrightness.toString());

            // No es necesario actualizar el visual aqu√≠, WLED lo maneja

            if (brightnessTimeout) {
                clearTimeout(brightnessTimeout);
            }

            brightnessTimeout = setTimeout(() => {
                addDebugLog(`üí° Aplicando brillo: ${currentBrightness}`, 'info');
                sendMQTTCommand({"bri": currentBrightness});

                // Publicar brillo en MQTT para sincronizar entre dispositivos
                if (mqttClient && mqttClient.connected) {
                    mqttClient.publish('wled/tree/brightness', currentBrightness.toString(), { retain: true });
                }
            }, 300); // 300ms debounce
        }
        
        function updateBrightnessLabel(value) {
            const percent = Math.round(value / 2.55);
            document.getElementById('brightVal').textContent = `${percent}%`;
        }

        // DISE√ëOS GUARDADOS (mantener todas las funciones existentes)
        function saveDesign() {
            const name = document.getElementById('designName').value.trim();
            if (!name) {
                showStatus('‚ùå Escribe un nombre para el dise√±o.', true);
                return;
            }
            
            const designToSave = {};
            for(const [index, color] of Object.entries(ledColors)) {
                if (color !== '#333333' && color !== '#000000') {
                    designToSave[index] = color;
                }
            }

            if (Object.keys(designToSave).length === 0) {
                 showStatus('‚ùå No hay LEDs encendidos para guardar.', true);
                 return;
            }

            let designs = JSON.parse(localStorage.getItem('wledDesigns')) || {};
            designs[name] = designToSave;
            localStorage.setItem('wledDesigns', JSON.stringify(designs));
            
            showStatus(`‚úì Dise√±o "${name}" guardado.`);
            addDebugLog(`üíæ Dise√±o guardado: ${name}`, 'success');
            document.getElementById('designName').value = '';
            loadDesigns();
        }

        function loadDesigns() {
            const designs = JSON.parse(localStorage.getItem('wledDesigns')) ||
            {};
            const listDiv = document.getElementById('designsList');
            listDiv.innerHTML = '';
            
            if (Object.keys(designs).length === 0) {
                listDiv.innerHTML = '<p style="color: #666; font-size: 14px;">No hay dise√±os guardados.</p>';
                return;
            }
            
            Object.keys(designs).forEach(name => {
                const item = document.createElement('div');
                item.className = 'design-item';
                item.innerHTML = `
                     <span>${escapeHTML(name)}</span>
                    <div>
                        <button onclick="applyDesign('${escapeHTML(name)}')">Cargar</button>
                        <button class="delete-btn" onclick="deleteDesign('${escapeHTML(name)}')">X</button>
                    </div>
                 `;
                listDiv.appendChild(item);
            });
        }

        async function applyDesign(name) {
            const designs = JSON.parse(localStorage.getItem('wledDesigns')) ||
            {};
            const design = designs[name];
            
            if (!design) {
                showStatus('‚ùå No se encontr√≥ el dise√±o.', true);
                return;
            }

            stopAllAnimations();
            
            const payload_i = [];
            for (let i = 0; i < totalLeds; i++) {
                ledColors[i] = '#333333';
                updateLEDVisual(i, '#333333', false);
            }
            
            for(const [index, color] of Object.entries(design)) {
                const rgb = hexToRgb(color);
                const idx = parseInt(index);
                payload_i.push(idx, [rgb.r, rgb.g, rgb.b]);
                
                ledColors[idx] = color;
                updateLEDVisual(idx, color, false);
            }
            
            ledMeshes.forEach(mesh => {
                mesh.material.needsUpdate = true;
            });
            await sendMQTTCommand({
                "on": true,
                "seg": [{ "fx": 0, "i": payload_i }]
            });
            showStatus(`‚úì Dise√±o "${name}" cargado.`);
            addDebugLog(`üìÇ Dise√±o cargado: ${name}`, 'success');
        }

        function deleteDesign(name) {
            if (!confirm(`¬øSeguro que quieres borrar el dise√±o "${name}"?`)) {
                return;
            }
            let designs = JSON.parse(localStorage.getItem('wledDesigns')) || {};
            delete designs[name];
            localStorage.setItem('wledDesigns', JSON.stringify(designs));
            showStatus(`‚úì Dise√±o "${name}" borrado.`);
            addDebugLog(`üóëÔ∏è Dise√±o eliminado: ${name}`, 'info');
            loadDesigns();
        }
        
        // THREE.JS (mantener todas las funciones existentes)
        function initThreeJS() {
            const canvas = document.getElementById('treeCanvas');
            scene = new THREE.Scene();
            scene.background = null;
            
            camera = new THREE.PerspectiveCamera(50, canvas.clientWidth / canvas.clientHeight, 0.1, 1000);
            camera.position.set(0, 8, 25);
            camera.lookAt(0, 8, 0);
            
            renderer = new THREE.WebGLRenderer({ canvas: canvas, alpha: true, antialias: true });
            renderer.setSize(canvas.clientWidth, canvas.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const pointLight = new THREE.PointLight(0xffffff, 0.8);
            pointLight.position.set(0, 25, 20);
            scene.add(pointLight);
            
            createChristmasTree();
            let isDragging = false;
            let previousMousePosition = { x: 0, y: 0 };
            canvas.addEventListener('mousedown', () => {
                isDragging = true;
            });
            canvas.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    const deltaMove = {
                        x: e.offsetX - previousMousePosition.x,
                        y: e.offsetY - previousMousePosition.y
                     };
                    
                    ledGroup.rotation.y += deltaMove.x * 0.01;
                    ledGroup.rotation.x += deltaMove.y * 0.01;
                 }
                
                previousMousePosition = {
                    x: e.offsetX,
                    y: e.offsetY
                };
             });
            
            canvas.addEventListener('mouseup', () => {
                isDragging = false;
            });
            canvas.addEventListener('click', onCanvasClick);
            
            window.addEventListener('resize', onWindowResize);
            
            animate();
        }
        
        function createChristmasTree() {
            ledGroup = new THREE.Group();
            const treeHeight = 17;
            const treeRadius = 7;
            const treeGeometry = new THREE.ConeGeometry(treeRadius, treeHeight, 32);
            const treeMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x0a4d0a, 
                transparent: true, 
                opacity: 0.7 
            });
            const treeMesh = new THREE.Mesh(treeGeometry, treeMaterial);
            treeMesh.position.y = treeHeight / 2;
            ledGroup.add(treeMesh);
            
            const starGeometry = new THREE.SphereGeometry(0.8, 16, 16);
            const starMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            const starMesh = new THREE.Mesh(starGeometry, starMaterial);
            starMesh.position.y = treeHeight + 0.5;
            ledGroup.add(starMesh);
            const ledsPerLayer = 9;
            const layers = Math.ceil(totalLeds / ledsPerLayer);
            
            let ledIndex = 0;
            for (let layer = 0; layer < layers && ledIndex < totalLeds; layer++) {
                const ledsInThisLayer = Math.min(ledsPerLayer, totalLeds - ledIndex);
                for (let i = 0; i < ledsInThisLayer; i++) {
                    const angleOffset = (i / ledsInThisLayer) * (Math.PI * 2);
                    const y = (layer / layers) * treeHeight;
                    const radiusAtHeight = treeRadius * (1 - (y / treeHeight));
                    const spiralOffset = layer * 0.4;
                    const x = Math.cos(angleOffset + spiralOffset) * radiusAtHeight;
                    const z = Math.sin(angleOffset + spiralOffset) * radiusAtHeight;
                    
                    const ledGeometry = new THREE.SphereGeometry(0.2, 8, 8);
                    const ledMaterial = new THREE.MeshBasicMaterial({ color: 0x333333 });
                    const ledMesh = new THREE.Mesh(ledGeometry, ledMaterial);
                    
                    ledMesh.position.set(x, y, z);
                    ledMesh.userData.ledIndex = ledIndex;
                    ledGroup.add(ledMesh);
                    ledMeshes.push(ledMesh);
                    ledColors[ledIndex] = '#333333';
                    ledPositions[ledIndex] = { x, y, z };
                    
                    ledIndex++;
                }
            }

            scene.add(ledGroup);

            // Marcar que los LEDs est√°n listos
            ledsReady = true;
            addDebugLog(`‚úÖ ${totalLeds} LEDs creados y listos`, 'success');

            // Aplicar estado pendiente de WLED si existe
            if (pendingWLEDState) {
                addDebugLog('üîÑ Aplicando estado pendiente de WLED...', 'info');
                handleWLEDState(pendingWLEDState);
                pendingWLEDState = null;
            }
        }
        
        function onCanvasClick(event) {
            if (!paintMode) return;
            const canvas = document.getElementById('treeCanvas');
            const rect = canvas.getBoundingClientRect();
            
            const mouse = new THREE.Vector2(
                ((event.clientX - rect.left) / rect.width) * 2 - 1,
                -((event.clientY - rect.top) / rect.height) * 2 + 1
            );
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);
            
            const intersects = raycaster.intersectObjects(ledMeshes);
            if (intersects.length > 0) {
                const clickedLED = intersects[0].object;
                const ledIndex = clickedLED.userData.ledIndex;
                
                updateLEDColor(ledIndex, selectedColor);
            }
        }
        
        function animate() {
            requestAnimationFrame(animate);
            ledGroup.rotation.y += 0.001;
            renderer.render(scene, camera);
        }
        
        function onWindowResize() {
            const canvas = document.getElementById('treeCanvas');
            camera.aspect = canvas.clientWidth / canvas.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(canvas.clientWidth, canvas.clientHeight);
        }
        
        // UTILIDADES (mantener todas las funciones existentes)
        function generateStars() {
            const starsContainer = document.getElementById('stars');
            for(let i = 0; i < 100; i++) {
                const star = document.createElement('div');
                star.className = 'star';
                star.style.left = Math.random() * 100 + '%';
                star.style.top = Math.random() * 100 + '%';
                star.style.animationDelay = Math.random() * 3 + 's';
                starsContainer.appendChild(star);
            }
        }

        function showStatus(message, isError = false) {
            const oldMessage = document.querySelector('.status-message');
            if (oldMessage) oldMessage.remove();
            
            const status = document.createElement('div');
            status.className = 'status-message';
            status.textContent = message;
            if (isError) {
                status.style.background = '#dc3545';
            }
            document.body.appendChild(status);
            setTimeout(() => {
                status.remove();
            }, 3000);
        }

        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : null;
        }

        function rgbToHex(r, g, b) {
            return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
        }

        function hslToRgb(h, s, l) {
            s /= 100;
            l /= 100;
            const k = n => (n + h / 30) % 12;
            const a = s * Math.min(l, 1 - l);
            const f = n => l - a * Math.max(-1, Math.min(k(n) - 3, Math.min(9 - k(n), 1)));
            return {
                r: Math.round(255 * f(0)),
                g: Math.round(255 * f(8)),
                b: Math.round(255 * f(4))
            };
        }
        
        function escapeHTML(str) {
            return str.replace(/[&<>"']/g, function(m) {
                return {
                    '&': '&amp;',
                    '<': '&lt;',
                    '>': '&gt;',
                    '"': '&quot;',
                    "'": '&#39;'
                }[m];
            });
        }
        
        // =====================================================
        // INICIALIZACI√ìN
        // =====================================================
        
        window.onload = function() {
            addDebugLog('üöÄ Aplicaci√≥n iniciada', 'success');
            addDebugLog('üìù Versi√≥n completa con Scheduler', 'info');

            // Cargar √∫ltimo brillo conocido desde localStorage
            const savedBrightness = localStorage.getItem('lastBrightness');
            if (savedBrightness) {
                const brightness = parseInt(savedBrightness);
                currentBrightness = brightness;
                document.getElementById('brightness').value = brightness;
                updateBrightnessLabel(brightness);
                addDebugLog(`üí° Brillo restaurado: ${brightness}`, 'info');
            }

            initThreeJS();
            generateStars();
            loadDesigns();
            loadSchedules();
            // PRIMERO establecer conexi√≥n MQTT
            setTimeout(() => {
                initMQTT();
            }, 500);
            // DESPU√âS iniciar verificaci√≥n de horarios (solo si hay conexi√≥n)
            setTimeout(() => {
                // Verificar horarios solo cada 60 segundos en lugar de 30
                setInterval(() => {
                    if (mqttClient && mqttClient.connected) {
                         checkSchedules();
                    }
                }, 60000);
        
                // Primera verificaci√≥n despu√©s de conectar
                if (mqttClient && mqttClient.connected) {
                    checkSchedules();
                }
            }, 2000);
        };
    </script>
</body>
</html>
