<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üéÑ Christmas LED Tree - 3D WLED Edition</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: radial-gradient(ellipse at bottom, #1b2735 0%, #090a0f 100%);
            overflow: hidden;
            height: 100vh;
            color: #333;
        }
        
        .stars {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        
        .star {
            position: absolute;
            width: 2px;
            height: 2px;
            background: white;
            border-radius: 50%;
            animation: twinkle 3s infinite;
        }
        
        @keyframes twinkle {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 1; }
        }
        
        .main-container {
            display: flex;
            height: 100vh;
            position: relative;
            z-index: 1;
        }
        
        .tree-view {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
            position: relative;
        }
        
        .tree-container {
            position: relative;
            width: 90%;
            height: 90%;
            max-width: 800px;
            max-height: 900px;
        }
        
        #treeCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: grab;
        }
        #treeCanvas:active {
            cursor: grabbing;
        }
        
        .control-panel {
            width: 450px;
            background: rgba(255, 255, 255, 0.98);
            overflow-y: auto;
            box-shadow: -5px 0 30px rgba(0,0,0,0.3);
            display: flex;
            flex-direction: column;
        }
        
        .panel-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            text-align: center;
            position: sticky;
            top: 0;
            z-index: 10;
        }
        
        .panel-header h1 {
            font-size: 1.8em;
            margin-bottom: 5px;
        }
        
        .panel-content {
            padding: 20px;
            flex-grow: 1;
        }
        
        .section {
            background: white;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .section-title {
            font-size: 1.1em;
            font-weight: 600;
            color: #333;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .connection-status {
            padding: 10px;
            border-radius: 8px;
            text-align: center;
            font-weight: 600;
            margin-bottom: 15px;
        }
        
        .connection-status.connected {
            background: #d4edda;
            color: #155724;
        }
        
        .connection-status.disconnected {
            background: #f8d7da;
            color: #721c24;
        }
        
        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s;
            width: 100%;
            margin-bottom: 10px;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        button:active {
            transform: translateY(0);
            box-shadow: 0 2px 6px rgba(102, 126, 234, 0.3);
        }
        
        button.active {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            box-shadow: 0 0 20px rgba(79, 172, 254, 0.6);
        }
        
        button.danger {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }
        button.danger:hover {
            box-shadow: 0 4px 12px rgba(245, 87, 108, 0.4);
        }
        
        .color-selector {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-bottom: 15px;
        }
        
        input[type="color"] {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            width: 60px;
            height: 60px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            padding: 0;
            background-color: transparent;
        }
        input[type="color"]::-webkit-color-swatch-wrapper {
            padding: 0;
            border: 3px solid #ddd;
            border-radius: 8px;
        }
        input[type="color"]::-webkit-color-swatch {
            border: none;
            border-radius: 5px;
        }
        input[type="color"]::-moz-color-swatch {
            border: none;
            border-radius: 5px;
        }
        
        .brightness-control {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 15px 0;
        }
        
        input[type="range"] {
            flex: 1;
            height: 8px;
            border-radius: 5px;
            background: #ddd;
            outline: none;
            -webkit-appearance: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
        }
        
        .brightness-value {
            min-width: 50px;
            text-align: right;
            font-weight: 600;
            color: #667eea;
        }
        
        input[type="text"], input[type="time"] {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 14px;
            margin-bottom: 10px;
            transition: border 0.3s;
        }
        
        input[type="text"]:focus, input[type="time"]:focus {
            outline: none;
            border-color: #667eea;
        }
        
        .effects-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }
        
        .effect-btn {
            margin: 0;
            padding: 10px;
            font-size: 13px;
        }
        
        .color-palette {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 8px;
            margin-top: 10px;
        }
        
        .palette-color {
            width: 100%;
            aspect-ratio: 1;
            border-radius: 8px;
            cursor: pointer;
            border: 3px solid transparent;
            transition: all 0.3s;
        }
        
        .palette-color:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }
        
        .palette-color.selected {
            border-color: #667eea;
            transform: scale(1.1);
        }
        
        .design-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 8px;
            margin-bottom: 8px;
        }
        
        .design-item button {
            width: auto;
            margin: 0 5px;
            padding: 8px 15px;
        }
        
        .delete-btn {
            background: #dc3545 !important;
            padding: 8px 12px !important;
        }
        
        .timer-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 10px 0;
        }
        
        .timer-controls label {
            min-width: 80px;
            font-weight: 600;
        }
        
        .timer-controls input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }
        
        #currentTime {
            font-size: 2em;
            font-weight: bold;
            text-align: center;
            color: #667eea;
            margin-bottom: 15px;
        }
        
        .status-message {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #28a745;
            color: white;
            padding: 15px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            z-index: 1000;
            animation: slideIn 0.3s;
        }
        
        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        
        .animated-effects-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }
        
        .animated-effects-grid button {
            margin: 0;
            padding: 10px;
            font-size: 13px;
        }
        
        .animated-effects-grid button:last-child {
            grid-column: 1 / -1;
        }
        
        @media (max-width: 1024px) {
            .main-container {
                flex-direction: column;
            }
            
            .control-panel {
                width: 100%;
                max-height: 50vh;
            }
            
            .tree-view {
                height: 50vh;
            }
        }
    </style>
</head>
<body>
    <div id="stars" class="stars"></div>
    
    <div class="main-container">
        <div class="tree-view">
            <div class="tree-container">
                <canvas id="treeCanvas"></canvas>
            </div>
        </div>
        
        <div class="control-panel">
            <div class="panel-header">
                <h1>üéÑ Christmas LED Tree</h1>
                <p>3D WLED Edition</p>
            </div>
            
            <div class="panel-content">
                <!-- CONEXI√ìN -->
                <div class="section">
                    <div class="section-title">üîå Conexi√≥n</div>
                    <input type="text" id="wledIP" placeholder="Vittence.com" value="Vittence.com">
                    <button onclick="testConnection()">Probar y Sincronizar</button>
                    <button class="danger" onclick="resetWLED()">üîÑ Reset WLED</button>
                    <div id="connectionStatus" class="connection-status disconnected">
                        Desconectado
                    </div>
                </div>
                
                <!-- CONTROL DE COLOR -->
                <div class="section">
                    <div class="section-title">üé® LED Color</div>
                    <div class="color-selector">
                        <input type="color" id="ledColor" value="#ff0000" onchange="updateSelectedColor()">
                        <button onclick="activatePaintMode()" id="paintBtn">Activar Paint Mode</button>
                    </div>
                    
                    <div id="colorPalette" class="color-palette" style="display: none;">
                        <div class="palette-color selected" style="background: #ff0000" onclick="selectPaletteColor('#ff0000')"></div>
                        <div class="palette-color" style="background: #ffa500" onclick="selectPaletteColor('#ffa500')"></div>
                        <div class="palette-color" style="background: #ffff00" onclick="selectPaletteColor('#ffff00')"></div>
                        <div class="palette-color" style="background: #ffffff" onclick="selectPaletteColor('#ffffff')"></div>
                        <div class="palette-color" style="background: #00ff00" onclick="selectPaletteColor('#00ff00')"></div>
                        <div class="palette-color" style="background: #0000ff" onclick="selectPaletteColor('#0000ff')"></div>
                        <div class="palette-color" style="background: #4b0082" onclick="selectPaletteColor('#4b0082')"></div>
                        <div class="palette-color" style="background: #ee82ee" onclick="selectPaletteColor('#ee82ee')"></div>
                        <div class="palette-color" style="background: #333333" onclick="selectPaletteColor('#333333')"></div>
                    </div>
                </div>
                
                <!-- BRILLO -->
                <div class="section">
                    <div class="section-title">üí° Brightness</div>
                    <div class="brightness-control">
                        <input type="range" id="brightness" min="0" max="255" value="255" oninput="setBrightness(this.value)">
                        <span class="brightness-value" id="brightVal">100%</span>
                    </div>
                </div>
                
                <!-- DISE√ëOS EST√ÅTICOS -->
                <div class="section">
                    <div class="section-title">üé® Static Color Designs</div>
                    <div class="effects-grid">
                        <button class="effect-btn" onclick="setStaticDesign('OFF')">OFF</button>
                        <button class="effect-btn" onclick="setStaticDesign('Solid')">Solid</button>
                        <button class="effect-btn" onclick="setStaticDesign('Rainbow')">Rainbow</button>
                        <button class="effect-btn" onclick="setStaticDesign('Warm')">Warm</button>
                        <button class="effect-btn" onclick="setStaticDesign('Cold')">Cold</button>
                        <button class="effect-btn" onclick="setStaticDesign('Purple Rain')">Purple Rain</button>
                        <button class="effect-btn" onclick="setStaticDesign('Dominican')">Dominican</button>
                    </div>
                </div>
                
                <!-- DIAGN√ìSTICO DE COLORES -->
                <div class="section" style="background: #fff3cd; border: 2px solid #ffc107;">
                    <div class="section-title">üî¨ Diagn√≥stico de Colores</div>
                    <p style="font-size: 12px; margin-bottom: 10px; color: #856404;">
                        Prueba cada color. El √°rbol f√≠sico debe mostrar el mismo color del bot√≥n.
                    </p>
                    <div class="effects-grid">
                        <button style="background: #dc3545; margin: 0;" onclick="testColorDirect('red')">üî¥ Test ROJO</button>
                        <button style="background: #28a745; margin: 0;" onclick="testColorDirect('green')">üü¢ Test VERDE</button>
                        <button style="background: #007bff; margin: 0;" onclick="testColorDirect('blue')">üîµ Test AZUL</button>
                        <button style="background: linear-gradient(90deg, #dc3545 0%, #28a745 50%, #007bff 100%); margin: 0; color: white;" onclick="cycleColorTest()">üîÑ Ciclo RGB</button>
                    </div>
                    <p style="font-size: 11px; margin-top: 10px; color: #856404;">
                        Si los colores coinciden, la configuraci√≥n es correcta ‚úÖ
                    </p>
                    <button style="background: #6c757d; margin-top: 10px;" onclick="testIndividualLEDs()">üß™ Test LEDs Individuales (10 rojos)</button>
                    <button style="background: #17a2b8; margin-top: 5px;" onclick="checkWLEDState()">üìä Ver Estado WLED</button>
                </div>
                
                <!-- DISE√ëOS GUARDADOS -->
                <div class="section">
                    <div class="section-title">üìÅ My Designs</div>
                    <input type="text" id="designName" placeholder="Nombre del dise√±o">
                    <button onclick="saveDesign()">Guardar Dise√±o Actual</button>
                    <div id="designsList"></div>
                </div>
                
                <!-- EFECTOS ANIMADOS LOCALES -->
                <div class="section">
                    <div class="section-title">üåä Animated Effects (Movement)</div>
                    <p style="font-size: 12px; margin-bottom: 10px; color: #666;">
                        Estos efectos a√±aden movimiento a los dise√±os de color
                    </p>
                    <div class="animated-effects-grid">
                        <button onclick="runAnimatedEffect('Fire')">üî• Fire</button>
                        <button onclick="runAnimatedEffect('Chase')">üèÉ Chase</button>
                        <button onclick="runAnimatedEffect('Twinkle')">‚ú® Twinkle</button>
                        <button onclick="runAnimatedEffect('Sparkle')">üí´ Sparkle</button>
                        <button onclick="runAnimatedEffect('Ripple')">üåä Ripple</button>
                        <button onclick="runAnimatedEffect('Blink')">‚ö° Blink</button>
                        <button onclick="runAnimatedEffect('Scan')">üì° Scan</button>
                        <button onclick="runAnimatedEffect('Waves')">üåÄ Waves</button>
                        <button onclick="runAnimatedEffect('Fairy')">üßö Fairy</button>
                        <button onclick="runAnimatedEffect('Flow')">üåà Flow</button>
                        <button class="danger" onclick="stopAllAnimations()">‚èπ Stop Animation</button>
                    </div>
                </div>
                
                <!-- TIMER -->
                <div class="section">
                    <div class="section-title">‚è∞ Auto Timer</div>
                    <div id="currentTime">--:--</div>
                    <div class="timer-controls">
                        <label>
                            <input type="checkbox" id="timerEnabled" onchange="updateTimer()">
                            Enable Timer
                        </label>
                    </div>
                    <div class="timer-controls">
                        <label>ON</label>
                        <input type="time" id="onTime" value="15:00" onchange="updateTimer()">
                    </div>
                    <div class="timer-controls">
                        <label>OFF</label>
                        <input type="time" id="offTime" value="07:00" onchange="updateTimer()">
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/mqtt/dist/mqtt.min.js"></script>
    
    <script>
        // =====================================================
        // VARIABLES GLOBALES
        // =====================================================
        
	// MQTT Client
	let mqttClient = null;

        let scene, camera, renderer;
        let ledGroup;
        let ledMeshes = [];
        let ledColors = {};
        let ledPositions = [];
        
        const totalLeds = 179; // ‚Üê 179 LEDs en lugar de 300
        
        let paintMode = false;
        let selectedColor = '#ff0000';
        let currentBrightness = 255;
        
        let effectAnimationInterval = null;
        let localAnimationInterval = null;
        let currentEffect = null;
        let currentLocalAnimation = null;
        
        // ORDEN DE COLORES: RGB porque WLED ya convierte a GRB internamente
        // WLED est√° configurado como GRB en settings
        // Por lo tanto, enviamos RGB y WLED lo convierte autom√°ticamente
        let COLOR_ORDER = 'RGB'; // ‚Üê Enviamos RGB, WLED lo interpreta como GRB
        
        // Sistema SIMPLE con protecci√≥n anti-spam
        let lastRequestTime = 0;
        let isProcessingRequest = false;
        const MIN_REQUEST_INTERVAL = 300; // 300ms entre peticiones para m√°xima estabilidad
        
        // Funci√≥n directa para enviar a WLED con protecci√≥n anti-spam
        async function sendToWLED(payload) {
    	   // PROTECCI√ìN: Si hay una petici√≥n en proceso, ignorar
    	   if (isProcessingRequest) {
        	console.log('‚è≠Ô∏è Petici√≥n ignorada (otra en proceso)');
        	return false;
    	   }
    
    	// ============================================
		// PRIORIDAD 1: MQTT (solo para comandos simples)
		// ============================================
		if (mqttClient && mqttClient.connected) {
  		  const payloadStr = JSON.stringify(payload);
    
   		 // LIMITAR MQTT solo a comandos peque√±os (<200 caracteres)
   		 if (payloadStr.length < 200) {
     		   isProcessingRequest = true;
      		  console.log('üì§ MQTT ‚Üí Enviando:', payloadStr.substring(0, 100));
        
      		  try {
        		    mqttClient.publish('wled/tree/api', payloadStr, { qos: 1, retain: false });
      		      console.log('‚úÖ Enviado v√≠a MQTT');
            
           		 await new Promise(resolve => setTimeout(resolve, 100));
           		 return true;
            
        		} catch (error) {
          		  console.error('‚ùå Error MQTT:', error);
           		 showStatus('‚ùå Error MQTT', true);
          		  return false;
            
      		  } finally {
           		 isProcessingRequest = false;
        		}
    		} else {
        		// Payload muy grande ‚Üí usar HTTP
        		console.log('‚ö†Ô∏è Payload grande, usando HTTP en lugar de MQTT');
        		// Continuar con HTTP abajo...
    		}
		}
    
    	// ============================================
    	// FALLBACK: HTTP Local (si MQTT no est√° disponible)
    	// ============================================
    	const baseUrl = getWLEDUrl();
    	if (!baseUrl) {
           console.log('‚ùå Sin conexi√≥n (ni MQTT ni HTTP)');
           showStatus('‚ùå Sin conexi√≥n con WLED', true);
           return false;
    	}
    
    	// Esperar intervalo m√≠nimo desde √∫ltima petici√≥n
    	const now = Date.now();
    	const timeSinceLastRequest = now - lastRequestTime;
    	if (timeSinceLastRequest < MIN_REQUEST_INTERVAL) {
           const waitTime = MIN_REQUEST_INTERVAL - timeSinceLastRequest;
           console.log(`‚è≥ Esperando ${waitTime}ms...`);
           await new Promise(resolve => setTimeout(resolve, waitTime));
    	}
    
    	isProcessingRequest = true;
    	console.log('üì§ HTTP ‚Üí Enviando:', JSON.stringify(payload));
    
    	try {
           lastRequestTime = Date.now();
        
        const response = await fetch(`${baseUrl}/json/state`, {
            method: 'POST',
            mode: 'cors',
            cache: 'no-cache',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(payload),
            signal: AbortSignal.timeout(5000)  // 5 segundos
        });
        
        if (!response.ok) {
            console.error(`‚ùå HTTP ${response.status}`);
            return false;
        }
        
        await response.json();
        console.log('‚úÖ OK v√≠a HTTP');
        return true;
        
    	} catch (error) {
        	if (error.name === 'TimeoutError' || error.name === 'AbortError') {
            	console.error('‚ùå Timeout HTTP');
        } else {
            console.error('‚ùå Error HTTP:', error.message);
        }
        return false;
    	} finally {
        	isProcessingRequest = false;
    	   }
	}

	// =====================================================
	// MQTT CONNECTION
	// =====================================================

	function initMQTT() {
    	console.log('üîå Iniciando conexi√≥n MQTT...');
    
   	 // CAMBIO CLAVE: Usar WSS en el puerto 443 o la URL simple
    	// Aseg√∫rate de que tu configuraci√≥n de HiveMQ soporta WSS en el puerto 443.
    	// Si tu broker HiveMQ usa un puerto diferente para WSS (ej: 8884 o 8084), debes usarlo, 
    	// pero recuerda que 8884 tiene alta probabilidad de ser bloqueado por Hostinger.
    	const broker = 'wss://90717923c01b4a4da3718559007344ac.s1.eu.hivemq.cloud:8884/mqtt'

    	mqttClient = mqtt.connect(broker, {
       	 username: 'wled_user',
        	// ‚ö†Ô∏è ASEG√öRATE DE QUE ESTE ES TU PASSWORD REAL DE HIVEQ.
        	password: 'WledMqtt2024!', 
        	clientId: 'web-controller-' + Math.random().toString(16).substr(2, 8),
        	clean: true,
        	reconnectPeriod: 5000,
        	connectTimeout: 10000,
        	// A√±adir una propiedad para el protocolo si el cliente mqtt.js lo requiere para WSS.
        	protocol: 'wss' 
    	});
    
    	// ... (El resto de manejadores de eventos 'connect', 'error', 'reconnect', etc., est√° bien)
    	// ...
    	mqttClient.on('connect', () => {
        	console.log('‚úÖ Conectado a MQTT Broker');
        	showStatus('‚úÖ Conectado a MQTT');
        
        	// Suscribirse para recibir estados del ESP (WLED)
        	// Se recomienda suscribirse a los topics de estado de WLED para recibir feedback.
        	mqttClient.subscribe('wled/tree/status/#', (err) => { // wled/CLIENT_ID/status/#
             	if (!err) {
                	 console.log('üì° Suscrito a topics de estado WLED');
             	}
         	});
         
        // El topic de comando que usas es 'wled/tree/api'
    	});
   	 
   	 mqttClient.on('error', (err) => {
    	    console.error('‚ùå Error MQTT:', err);
    	    showStatus('‚ùå Error MQTT: ' + err.message, true);
    	});
    
    	mqttClient.on('reconnect', () => {
    	    console.log('üîÑ Reconectando MQTT...');
  	  });
    
  	  mqttClient.on('offline', () => {
   	     console.log('‚ö†Ô∏è MQTT offline');
  	      showStatus('‚ö†Ô∏è Desconectado de MQTT', true);
 	   });
    
   	   mqttClient.on('message', (topic, message) => {
   	     		console.log('üì® Mensaje recibido:', topic, message.toString());
    	   });
	}
        
        // Funci√≥n para convertir RGB seg√∫n el orden correcto
        function applyColorOrder(r, g, b) {
            switch(COLOR_ORDER) {
                case 'RGB':
                    return [r, g, b];
                case 'GRB':
                    return [g, r, b];
                case 'BGR':
                    return [b, g, r];
                case 'RBG':
                    return [r, b, g];
                case 'GBR':
                    return [g, b, r];
                case 'BRG':
                    return [b, r, g];
                default:
                    return [r, g, b];
            }
        }
        
        // =====================================================
        // INICIALIZACI√ìN
        // =====================================================
        
        window.onload = function() {
    	   console.log('üöÄ Iniciando aplicaci√≥n...');
    
    	   // IMPORTANTE: Iniciar MQTT primero
    	   initMQTT();
    
    	   // Luego el resto de inicializaciones
    	   initThreeJS();
    	   generateStars();
    	   loadDesigns();
    	   loadTimerSettings();
    	   updateClock();
    	   setInterval(updateClock, 1000);
    	   setInterval(checkTimer, 60000);
    
    	   const savedIP = localStorage.getItem('wledIP');
    	   if (savedIP) {
        	document.getElementById('wledIP').value = savedIP;
    	   }
	};
        
        // =====================================================
        // THREE.JS
        // =====================================================
        
        function initThreeJS() {
            const canvas = document.getElementById('treeCanvas');
            
            scene = new THREE.Scene();
            scene.background = null;
            
            camera = new THREE.PerspectiveCamera(50, canvas.clientWidth / canvas.clientHeight, 0.1, 1000);
            camera.position.set(0, 8, 25);
            camera.lookAt(0, 8, 0);
            
            renderer = new THREE.WebGLRenderer({ canvas: canvas, alpha: true, antialias: true });
            renderer.setSize(canvas.clientWidth, canvas.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const pointLight = new THREE.PointLight(0xffffff, 0.8);
            pointLight.position.set(0, 25, 20);
            scene.add(pointLight);
            
            createChristmasTree();
            
            let isDragging = false;
            let previousMousePosition = { x: 0, y: 0 };
            
            canvas.addEventListener('mousedown', () => {
                isDragging = true;
            });
            
            canvas.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    const deltaMove = {
                        x: e.offsetX - previousMousePosition.x,
                        y: e.offsetY - previousMousePosition.y
                    };
                    
                    ledGroup.rotation.y += deltaMove.x * 0.01;
                    ledGroup.rotation.x += deltaMove.y * 0.01;
                }
                
                previousMousePosition = {
                    x: e.offsetX,
                    y: e.offsetY
                };
            });
            
            canvas.addEventListener('mouseup', () => {
                isDragging = false;
            });
            
            canvas.addEventListener('click', onCanvasClick);
            
            window.addEventListener('resize', onWindowResize);
            
            animate();
        }
        
        function createChristmasTree() {
            ledGroup = new THREE.Group();
            
            // ‚Üê CAMBIOS: √Årbol un poco m√°s peque√±o para 179 LEDs
            const treeHeight = 17;      // Reducido de 20 a 17
            const treeRadius = 7;        // Reducido de 8 a 7
            const treeGeometry = new THREE.ConeGeometry(treeRadius, treeHeight, 32);
            const treeMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x0a4d0a, 
                transparent: true, 
                opacity: 0.7 
            });
            const treeMesh = new THREE.Mesh(treeGeometry, treeMaterial);
            treeMesh.position.y = treeHeight / 2;
            ledGroup.add(treeMesh);
            
            const starGeometry = new THREE.SphereGeometry(0.8, 16, 16);
            const starMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            const starMesh = new THREE.Mesh(starGeometry, starMaterial);
            starMesh.position.y = treeHeight + 0.5;
            ledGroup.add(starMesh);
            
            // ‚Üê CAMBIOS: Ajustada la distribuci√≥n para 179 LEDs
            // Con 179 LEDs y 9 LEDs por capa = 19.88 capas ‚âà 20 capas
            const ledsPerLayer = 9;
            const layers = Math.ceil(totalLeds / ledsPerLayer);
            
            let ledIndex = 0;
            
            for (let layer = 0; layer < layers && ledIndex < totalLeds; layer++) {
                const ledsInThisLayer = Math.min(ledsPerLayer, totalLeds - ledIndex);
                
                for (let i = 0; i < ledsInThisLayer; i++) {
                    const angleOffset = (i / ledsInThisLayer) * (Math.PI * 2);
                    const y = (layer / layers) * treeHeight;
                    const radiusAtHeight = treeRadius * (1 - (y / treeHeight));
                    
                    // Peque√±a variaci√≥n en el √°ngulo para crear espiral m√°s natural
                    const spiralOffset = layer * 0.4;
                    const x = Math.cos(angleOffset + spiralOffset) * radiusAtHeight;
                    const z = Math.sin(angleOffset + spiralOffset) * radiusAtHeight;
                    
                    const ledGeometry = new THREE.SphereGeometry(0.2, 8, 8);
                    const ledMaterial = new THREE.MeshBasicMaterial({ color: 0x333333 });
                    const ledMesh = new THREE.Mesh(ledGeometry, ledMaterial);
                    
                    ledMesh.position.set(x, y, z);
                    ledMesh.userData.ledIndex = ledIndex;
                    
                    ledGroup.add(ledMesh);
                    ledMeshes.push(ledMesh);
                    ledColors[ledIndex] = '#333333';
                    ledPositions[ledIndex] = { x, y, z };
                    
                    ledIndex++;
                }
            }
            
            scene.add(ledGroup);
        }
        
        function onCanvasClick(event) {
            if (!paintMode) return;
            
            const canvas = document.getElementById('treeCanvas');
            const rect = canvas.getBoundingClientRect();
            
            const mouse = new THREE.Vector2(
                ((event.clientX - rect.left) / rect.width) * 2 - 1,
                -((event.clientY - rect.top) / rect.height) * 2 + 1
            );
            
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);
            
            const intersects = raycaster.intersectObjects(ledMeshes);
            
            if (intersects.length > 0) {
                const clickedLED = intersects[0].object;
                const ledIndex = clickedLED.userData.ledIndex;
                
                updateLEDColor(ledIndex, selectedColor);
            }
        }
        
        function animate() {
            requestAnimationFrame(animate);
            ledGroup.rotation.y += 0.001;
            renderer.render(scene, camera);
        }
        
        function onWindowResize() {
            const canvas = document.getElementById('treeCanvas');
            camera.aspect = canvas.clientWidth / canvas.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(canvas.clientWidth, canvas.clientHeight);
        }
        
        // =====================================================
        // GESTI√ìN DE CONEXI√ìN
        // =====================================================
        
        function getWLEDUrl() {
    			const ip = document.getElementById('wledIP').value.trim();
    			if (!ip) return null;
    			// Auto-detectar HTTP o HTTPS seg√∫n c√≥mo se carga la p√°gina
    			if (ip.startsWith('http')) return ip;
   			 const protocol = window.location.protocol === 'https:' ? 'https://' : 'http://';
    			return `${protocol}${ip}`;
	}
        
        async function testConnection() {
            const ip = document.getElementById('wledIP').value.trim();
            if (!ip) {
                showStatus('‚ùå Introduce la IP de WLED', true);
                return;
            }
            
            const baseUrl = getWLEDUrl();
            showStatus('üîÑ Conectando...');
            
            try {
                const response = await fetch(`${baseUrl}/json/state`, {
                    method: 'GET',
                    signal: AbortSignal.timeout(3000)
                });
                
                if (response.ok) {
                    const data = await response.json();
                    document.getElementById('connectionStatus').className = 'connection-status connected';
                    document.getElementById('connectionStatus').textContent = '‚úÖ Conectado';
                    localStorage.setItem('wledIP', ip);
                    showStatus(`‚úì Conectado a WLED - ${totalLeds} LEDs`);
                    
                    syncWithWLED(data);
                } else {
                    throw new Error('Error de conexi√≥n');
                }
            } catch (error) {
                document.getElementById('connectionStatus').className = 'connection-status disconnected';
                document.getElementById('connectionStatus').textContent = '‚ùå Desconectado';
                showStatus('‚ùå No se pudo conectar. Verifica la IP.', true);
            }
        }
        
        function syncWithWLED(state) {
            if (!state || !state.seg || !state.seg[0]) return;
            
            const segment = state.seg[0];
            
            if (segment.col && segment.col[0]) {
                const [r, g, b] = segment.col[0];
                const color = rgbToHex(r, g, b);
                selectedColor = color;
                document.getElementById('ledColor').value = color;
            }
            
            if (typeof state.bri !== 'undefined') {
                currentBrightness = state.bri;
                document.getElementById('brightness').value = state.bri;
                const percent = Math.round((state.bri / 255) * 100);
                document.getElementById('brightVal').textContent = `${percent}%`;
            }
        }
        
        async function resetWLED() {
            if (!confirm('¬øResetear WLED? Esto apagar√° todas las luces.')) {
                return;
            }
            
            stopAllAnimations();
            
            await sendToWLED({
                "on": false,
                "seg": [{
                    "fx": 0,
                    "sx": 0,
                    "ix": 0,
                    "pal": 0,
                    "col": [[0,0,0]]
                }]
            });
            
            updateAllLEDsVisual('#000000');
            showStatus('‚úì WLED reseteado');
        }
        
        async function checkWLEDState() {
            const baseUrl = getWLEDUrl();
            if (!baseUrl) {
                showStatus('‚ùå Primero conecta WLED', true);
                return;
            }
            
            try {
                const response = await fetch(`${baseUrl}/json/state`);
                const data = await response.json();
                
                console.log('üìä Estado WLED:', data);
                
                let info = `Estado WLED:\n`;
                info += `‚Ä¢ Encendido: ${data.on ? 'S√≠' : 'No'}\n`;
                info += `‚Ä¢ Brillo: ${data.bri}/255\n`;
                
                if (data.seg && data.seg[0]) {
                    const seg = data.seg[0];
                    info += `‚Ä¢ Efecto: ${seg.fx}\n`;
                    info += `‚Ä¢ Color: RGB(${seg.col[0].join(', ')})\n`;
                }
                
                alert(info);
            } catch (error) {
                showStatus('‚ùå Error al obtener estado', true);
            }
        }
        
        // =====================================================
        // TEST DE COLORES
        // =====================================================
        
        async function testColorDirect(color) {
            stopAllAnimations();
            
            let rgb;
            switch(color) {
                case 'red':
                    rgb = [255, 0, 0];
                    break;
                case 'green':
                    rgb = [0, 255, 0];
                    break;
                case 'blue':
                    rgb = [0, 0, 255];
                    break;
                default:
                    return;
            }
            
            const orderedRgb = applyColorOrder(...rgb);
            const hexColor = rgbToHex(...rgb);
            
            updateAllLEDsVisual(hexColor);
            
            await sendToWLED({
                "on": true,
                "seg": [{
                    "fx": 0,
                    "col": [orderedRgb]
                }]
            });
            
            showStatus(`‚úì Test ${color.toUpperCase()}: ${hexColor}`);
        }
        
        async function cycleColorTest() {
            stopAllAnimations();
            const colors = [
                { name: 'ROJO', rgb: [255, 0, 0], hex: '#FF0000' },
                { name: 'VERDE', rgb: [0, 255, 0], hex: '#00FF00' },
                { name: 'AZUL', rgb: [0, 0, 255], hex: '#0000FF' }
            ];
            
            for (const color of colors) {
                const orderedRgb = applyColorOrder(...color.rgb);
                updateAllLEDsVisual(color.hex);
                
                await sendToWLED({
                    "on": true,
                    "seg": [{
                        "fx": 0,
                        "col": [orderedRgb]
                    }]
                });
                
                showStatus(`üîÑ Ciclo: ${color.name}`);
                await new Promise(resolve => setTimeout(resolve, 2000));
            }
            
            showStatus('‚úì Ciclo RGB completado');
        }
        
        async function testIndividualLEDs() {
            stopAllAnimations();
            
            updateAllLEDsVisual('#000000');
            
            await sendToWLED({
                "on": true,
                "seg": [{ "fx": 0, "col": [[0, 0, 0]] }]
            });
            
            await new Promise(resolve => setTimeout(resolve, 500));
            
            const payload_i = [];
            for (let i = 0; i < Math.min(10, totalLeds); i++) {
                const rgb = applyColorOrder(255, 0, 0);
                payload_i.push(i, rgb);
                updateLEDVisual(i, '#FF0000', false);
            }
            
            ledMeshes.forEach(mesh => {
                mesh.material.needsUpdate = true;
            });
            
            await sendToWLED({
                "on": true,
                "seg": [{ "fx": 0, "i": payload_i }]
            });
            
            showStatus(`‚úì Test: Primeros ${Math.min(10, totalLeds)} LEDs en rojo`);
        }
        
        // =====================================================
        // CONTROL DE LEDS
        // =====================================================
        
        function activatePaintMode() {
            paintMode = !paintMode;
            const btn = document.getElementById('paintBtn');
            const palette = document.getElementById('colorPalette');
            
            if (paintMode) {
                btn.classList.add('active');
                btn.textContent = 'Paint Mode: ON';
                palette.style.display = 'grid';
                showStatus('üé® Paint Mode activado: Haz clic en los LEDs');
            } else {
                btn.classList.remove('active');
                btn.textContent = 'Activar Paint Mode';
                palette.style.display = 'none';
                showStatus('Paint Mode desactivado');
            }
        }
        
        function updateSelectedColor() {
            selectedColor = document.getElementById('ledColor').value;
        }
        
        function selectPaletteColor(color) {
            selectedColor = color;
            document.getElementById('ledColor').value = color;
            
            document.querySelectorAll('.palette-color').forEach(el => {
                el.classList.remove('selected');
            });
            event.target.classList.add('selected');
        }
        
        async function updateLEDColor(index, color) {
    		if (index < 0 || index >= totalLeds) return;
    
   		 ledColors[index] = color;
   		 updateLEDVisual(index, color, true);
    
    		const rgb = hexToRgb(color);
    		if (!rgb) return;
    
   		 const orderedRgb = applyColorOrder(rgb.r, rgb.g, rgb.b);
    
   		 // Comando simplificado para un LED
    		await sendToWLED({
       		 "seg": [{
         		   "i": [index, orderedRgb]  // Solo este LED
       		 }]
    		});
		}
        
        function updateLEDVisual(index, color, needsUpdate = true) {
            if (index < 0 || index >= totalLeds || !ledMeshes[index]) return;
            
            const mesh = ledMeshes[index];
            mesh.material.color.set(color);
            
            if (needsUpdate) {
                mesh.material.needsUpdate = true;
            }
        }
        
        function updateAllLEDsVisual(color) {
            for (let i = 0; i < totalLeds; i++) {
                ledColors[i] = color;
                updateLEDVisual(i, color, false);
            }
            
            ledMeshes.forEach(mesh => {
                mesh.material.needsUpdate = true;
            });
        }
        
        // =====================================================
        // DISE√ëOS EST√ÅTICOS (SIN MOVIMIENTO)
        // =====================================================
        
        function setStaticDesign(designName) {
            stopAllAnimations();
            currentEffect = designName;
            
            console.log(`üé® Aplicando dise√±o est√°tico: ${designName}`);
            
            // Actualizar botones
            document.querySelectorAll('.effect-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            if (event && event.target) {
                event.target.classList.add('active');
            }
            
            switch(designName) {
                case 'OFF':
                    applyOFFDesign();
                    break;
                case 'Solid':
                    applySolidDesign();
                    break;
                case 'Rainbow':
                    applyRainbowDesign();
                    break;
                case 'Warm':
                    applyWarmDesign();
                    break;
                case 'Cold':
                    applyColdDesign();
                    break;
                case 'Purple Rain':
                    applyPurpleRainDesign();
                    break;
                case 'Dominican':
                    applyDominicanDesign();
                    break;
            }
        }

        // Dise√±o OFF: Apagar todos los LEDs
        async function applyOFFDesign() {
            updateAllLEDsVisual('#000000');
            await sendToWLED({ "on": false });
            showStatus('‚úì LEDs apagados');
        }

        // Dise√±o Solid: Color s√≥lido del selector
        async function applySolidDesign() {
            updateAllLEDsVisual(selectedColor);
            const rgb = hexToRgb(selectedColor);
            
            console.log(`üé® Solid: ${selectedColor}`);
            
            // UNA SOLA petici√≥n simple
            await sendToWLED({
                "on": true,
                "bri": currentBrightness,
                "seg": [{
                    "id": 0,
                    "fx": 0,
                    "col": [applyColorOrder(rgb.r, rgb.g, rgb.b)]
                }]
            });
            
            showStatus(`‚úì Solid ${selectedColor}`);
        }

        // Dise√±o Rainbow: Arco√≠ris est√°tico usando paleta de WLED
        async function applyRainbowDesign() {
            console.log('üåà Aplicando Rainbow (1 petici√≥n)...');
            
            // Actualizar visual local
            for (let i = 0; i < totalLeds; i++) {
                const hue = (i * 360 / totalLeds) % 360;
                const color = hslToRgb(hue, 100, 50);
                const hexColor = rgbToHex(color.r, color.g, color.b);
                updateLEDVisual(i, hexColor, false);
            }
            ledMeshes.forEach(mesh => mesh.material.needsUpdate = true);
            
            // UNA SOLA petici√≥n con Rainbow
            await sendToWLED({
                "on": true,
                "bri": currentBrightness,
                "seg": [{
                    "id": 0,
                    "fx": 9,
                    "pal": 11
                }]
            });
            
            showStatus('‚úì Rainbow aplicado');
        }

        // Dise√±o Warm: Blanco c√°lido
        async function applyWarmDesign() {
            const warmColor = '#ffe4b5';
            updateAllLEDsVisual(warmColor);
            
            const rgb = hexToRgb(warmColor);
            
            // UNA SOLA petici√≥n simple
            await sendToWLED({
                "on": true,
                "bri": currentBrightness,
                "seg": [{
                    "id": 0,
                    "fx": 0,
                    "col": [applyColorOrder(rgb.r, rgb.g, rgb.b)]
                }]
            });
            
            showStatus('‚úì Warm aplicado');
        }

        // Dise√±o Cold: Colores fr√≠os usando paleta de WLED
        async function applyColdDesign() {
            console.log('‚ùÑÔ∏è Aplicando Cold (1 petici√≥n)...');
            
            // Actualizar visual local
            const coldColors = ['#0066ff', '#00ccff', '#6600ff', '#00ffff', '#3366ff'];
            for (let i = 0; i < totalLeds; i++) {
                const colorHex = coldColors[i % coldColors.length];
                updateLEDVisual(i, colorHex, false);
            }
            ledMeshes.forEach(mesh => mesh.material.needsUpdate = true);
            
            // UNA SOLA petici√≥n a WLED
            await sendToWLED({
                "on": true,
                "bri": currentBrightness,
                "seg": [{
                    "id": 0,
                    "fx": 67,
                    "pal": 9  // Ocean palette (colores fr√≠os)
                }]
            });
            
            showStatus('‚úì Cold aplicado');
        }

        // Dise√±o Purple Rain: Todo morado
        async function applyPurpleRainDesign() {
            const purpleColor = '#8b00ff';
            updateAllLEDsVisual(purpleColor);
            
            const rgb = hexToRgb(purpleColor);
            
            // UNA SOLA petici√≥n simple
            await sendToWLED({
                "on": true,
                "bri": currentBrightness,
                "seg": [{
                    "id": 0,
                    "fx": 0,
                    "col": [applyColorOrder(rgb.r, rgb.g, rgb.b)]
                }]
            });
            
            showStatus('‚úì Purple Rain aplicado');
        }

        // Dise√±o Dominican: Rojo/Blanco/Azul usando 3 segmentos
        async function applyDominicanDesign() {
            console.log('üá©üá¥ Aplicando Dominican (1 petici√≥n)...');
            
            const third = Math.floor(totalLeds / 3);
            
            // Actualizar visual local
            for (let i = 0; i < totalLeds; i++) {
                let colorHex;
                if (i < third) {
                    colorHex = '#0000ff'; // Azul abajo
                } else if (i < third * 2) {
                    colorHex = '#ffffff'; // Blanco medio
                } else {
                    colorHex = '#ff0000'; // Rojo arriba
                }
                updateLEDVisual(i, colorHex, false);
            }
            ledMeshes.forEach(mesh => mesh.material.needsUpdate = true);
            
            // UNA SOLA petici√≥n a WLED
            await sendToWLED({
                "on": true,
                "bri": currentBrightness,
                "seg": [{
                    "id": 0,
                    "fx": 2,
                    "pal": 255  // Dominican palette
                }]
            });
            
            showStatus('‚úì Dominican aplicado üá©üá¥');
        }
        
        // =====================================================
        // EFECTOS ANIMADOS (CON MOVIMIENTO)
        // =====================================================
        
        function runAnimatedEffect(effectName) {
            // No detener el dise√±o de color, solo a√±adir movimiento
            if (effectAnimationInterval) {
                clearInterval(effectAnimationInterval);
            }
            if (localAnimationInterval) {
                clearInterval(localAnimationInterval);
            }
            
            currentLocalAnimation = effectName;
            showStatus(`üîÑ Animaci√≥n "${effectName}" iniciada`);
            
            // Aplicar animaci√≥n correspondiente
            switch(effectName) {
                case 'Fire':
                    animateFire();
                    sendWLEDEffect(12); // Fire effect en WLED
                    break;
                case 'Chase':
                    animateChase();
                    sendWLEDEffect(28); // Chase effect en WLED
                    break;
                case 'Twinkle':
                    animateTwinkle();
                    sendWLEDEffect(17); // Twinkle effect en WLED
                    break;
                case 'Sparkle':
                    animateSparkle();
                    sendWLEDEffect(20); // Sparkle effect en WLED
                    break;
                case 'Ripple':
                    animateRipple();
                    sendWLEDEffect(79); // Ripple effect en WLED
                    break;
                case 'Blink':
                    animateBlink();
		    sendWLEDEffect(1); // Blink effect en WLED
                    break;
                case 'Scan':
                    animateScan();
                    sendWLEDEffect(10); // Scan effect en WLED
                    break;
                case 'Waves':
                    animateWaves();
		    sendWLEDEffect(67);
                    break;
                case 'Fairy':
                    animateFairy();
		    sendWLEDEffect(49);
                    break;
                case 'Flow':
                    animateFlow();
                    sendWLEDEffect(110); // Flow effect en WLED
                    break;
            }
        }

        async function sendWLEDEffect(fxNumber) {
            const rgb = hexToRgb(selectedColor);
            const colorArray = applyColorOrder(rgb.r, rgb.g, rgb.b);
            
            await sendToWLED({
                "on": true,
                "bri": currentBrightness,
                "mainseg": 0,
                "seg": [{
                    "id": 0,
                    "fx": fxNumber,
		    "pal": designName,
                    "col": [colorArray, [0, 0, 0], [0, 0, 0]]
                }]
            });
        }

        function animateFire() {
            effectAnimationInterval = setInterval(() => {
                for (let i = 0; i < totalLeds; i++) {
                    const intensity = Math.random();
                    const r = 255;
                    const g = Math.floor(intensity * 150);
                    const b = 0;
                    const hexColor = rgbToHex(r, g, b);
                    updateLEDVisual(i, hexColor, false);
                }
                ledMeshes.forEach(mesh => mesh.material.needsUpdate = true);
            }, 100);
        }

        function animateChase() {
            let pos = 0;
            effectAnimationInterval = setInterval(() => {
                for (let i = 0; i < totalLeds; i++) {
                    if (i % 10 === pos) {
                        updateLEDVisual(i, selectedColor, false);
                    } else {
                        updateLEDVisual(i, '#000000', false);
                    }
                }
                ledMeshes.forEach(mesh => mesh.material.needsUpdate = true);
                pos = (pos + 1) % 10;
            }, 100);
        }

        function animateTwinkle() {
            effectAnimationInterval = setInterval(() => {
                for (let i = 0; i < totalLeds; i++) {
                    if (Math.random() > 0.95) {
                        updateLEDVisual(i, '#ffffff', false);
                    } else {
                        updateLEDVisual(i, selectedColor, false);
                    }
                }
                ledMeshes.forEach(mesh => mesh.material.needsUpdate = true);
            }, 200);
        }

        function animateSparkle() {
            effectAnimationInterval = setInterval(() => {
                for (let i = 0; i < totalLeds; i++) {
                    updateLEDVisual(i, selectedColor, false);
                }
                const sparkleIndex = Math.floor(Math.random() * totalLeds);
                updateLEDVisual(sparkleIndex, '#ffffff', false);
                ledMeshes.forEach(mesh => mesh.material.needsUpdate = true);
            }, 100);
        }

        function animateRipple() {
            let offset = 0;
            effectAnimationInterval = setInterval(() => {
                for (let i = 0; i < totalLeds; i++) {
                    const distance = Math.abs(i - totalLeds/2);
                    const wave = Math.sin((distance + offset) * 0.3) * 0.5 + 0.5;
                    const rgb = hexToRgb(selectedColor);
                    const hexColor = rgbToHex(
                        Math.floor(rgb.r * wave),
                        Math.floor(rgb.g * wave),
                        Math.floor(rgb.b * wave)
                    );
                    updateLEDVisual(i, hexColor, false);
                }
                ledMeshes.forEach(mesh => mesh.material.needsUpdate = true);
                offset += 1;
            }, 80);
        }

        function animateBlink() {
            let on = true;
            localAnimationInterval = setInterval(() => {
                if (on) {
                    updateAllLEDsVisual(selectedColor);
                    sendToWLED({ "on": true, "bri": currentBrightness });
                } else {
                    updateAllLEDsVisual('#000000');
                    sendToWLED({ "on": true, "bri": 0 });
                }
                on = !on;
            }, 500);
        }
        
        function animateScan() {
            let currentLed = 0;
            
            localAnimationInterval = setInterval(() => {
                // Solo actualizar visual local - NO enviar a WLED cada frame
                for (let i = 0; i < totalLeds; i++) {
                    if (i === currentLed) {
                        updateLEDVisual(i, selectedColor, false);
                    } else {
                        updateLEDVisual(i, '#000000', false);
                    }
                }
                ledMeshes.forEach(mesh => mesh.material.needsUpdate = true);
                
                currentLed = (currentLed + 1) % totalLeds;
            }, 50);
        }
        
        function animateWaves() {
            let offset = 0;
            
            localAnimationInterval = setInterval(() => {
                // Solo actualizar visual local
                const rgb = hexToRgb(designName);
                
                for (let i = 0; i < totalLeds; i++) {
                    const wave = Math.sin((i + offset) * 0.2) * 0.5 + 0.5;
                    const waveColor = rgbToHex(
                        Math.floor(rgb.r * wave),
                        Math.floor(rgb.g * wave),
                        Math.floor(rgb.b * wave)
                    );
                    updateLEDVisual(i, waveColor, false);
                }
                ledMeshes.forEach(mesh => mesh.material.needsUpdate = true);
                
                offset += 1;
            }, 100);
        }
        
        function animateFairy() {
            localAnimationInterval = setInterval(() => {
                // Solo actualizar visual local
                for (let i = 0; i < totalLeds; i++) {
                    if (Math.random() > 0.7) {
                        updateLEDVisual(i, selectedColor, false);
                    } else {
                        updateLEDVisual(i, '#000000', false);
                    }
                }
                ledMeshes.forEach(mesh => mesh.material.needsUpdate = true);
            }, 200);
        }
        
        function animateFlow() {
            let hue = 0;
            
            localAnimationInterval = setInterval(() => {
                // Solo actualizar visual local
                for (let i = 0; i < totalLeds; i++) {
                    const ledHue = (hue + (i * 360 / totalLeds)) % 360;
                    const color = hslToRgb(ledHue, 100, 50);
                    const hexColor = rgbToHex(color.r, color.g, color.b);
                    updateLEDVisual(i, hexColor, false);
                }
                ledMeshes.forEach(mesh => mesh.material.needsUpdate = true);
                
                hue = (hue + 5) % 360;
            }, 100);
        }

        // Detener todas las animaciones (mantiene el dise√±o est√°tico actual)
        function stopAllAnimations() {
            if (effectAnimationInterval) {
                clearInterval(effectAnimationInterval);
                effectAnimationInterval = null;
            }
            if (localAnimationInterval) {
                clearInterval(localAnimationInterval);
                localAnimationInterval = null;
            }
            currentLocalAnimation = null;
            showStatus('‚èπ Animaci√≥n detenida - dise√±o est√°tico mantenido');
        }
        
        // =====================================================
        // BRILLO
        // =====================================================
        
        // Variable para debouncing del brillo
        let brightnessTimeout = null;
        
        function setBrightness(value) {
            currentBrightness = parseInt(value);
            updateBrightnessLabel(value);
            
            // Actualizar visual local inmediatamente
            for (let i = 0; i < totalLeds; i++) {
                updateLEDVisual(i, ledColors[i] || selectedColor, false);
            }
            ledMeshes.forEach(mesh => mesh.material.needsUpdate = true);
            
            // DEBOUNCING: Esperar 300ms despu√©s de que dejes de mover el slider
            if (brightnessTimeout) {
                clearTimeout(brightnessTimeout);
            }
            
            brightnessTimeout = setTimeout(() => {
                console.log(`üí° Aplicando brillo: ${currentBrightness}`);
                sendToWLED({"bri": currentBrightness});
            }, 300); // Solo env√≠a 300ms despu√©s de que dejes de mover
        }
        
        function updateBrightnessLabel(value) {
            const percent = Math.round(value / 2.55);
            document.getElementById('brightVal').textContent = `${percent}%`;
        }

        // =====================================================
        // DISE√ëOS
        // =====================================================

        function saveDesign() {
            const name = document.getElementById('designName').value.trim();
            if (!name) {
                showStatus('‚ùå Escribe un nombre para el dise√±o.', true);
                return;
            }
            
            const designToSave = {};
            for(const [index, color] of Object.entries(ledColors)) {
                if (color !== '#333333' && color !== '#000000') {
                    designToSave[index] = color;
                }
            }

            if (Object.keys(designToSave).length === 0) {
                 showStatus('‚ùå No hay LEDs encendidos para guardar.', true);
                return;
            }

            let designs = JSON.parse(localStorage.getItem('wledDesigns')) || {};
            designs[name] = designToSave;
            localStorage.setItem('wledDesigns', JSON.stringify(designs));
            
            showStatus(`‚úì Dise√±o "${name}" guardado.`);
            document.getElementById('designName').value = '';
            loadDesigns();
        }

        function loadDesigns() {
            const designs = JSON.parse(localStorage.getItem('wledDesigns')) || {};
            const listDiv = document.getElementById('designsList');
            listDiv.innerHTML = '';
            
            if (Object.keys(designs).length === 0) {
                listDiv.innerHTML = '<p style="color: #666; font-size: 14px;">No hay dise√±os guardados.</p>';
                return;
            }
            
            Object.keys(designs).forEach(name => {
                const item = document.createElement('div');
                item.className = 'design-item';
                item.innerHTML = `
                    <span>${escapeHTML(name)}</span>
                    <div>
                        <button onclick="applyDesign('${escapeHTML(name)}')">Cargar</button>
                        <button class="delete-btn" onclick="deleteDesign('${escapeHTML(name)}')">X</button>
                    </div>
                `;
                listDiv.appendChild(item);
            });
        }

        async function applyDesign(name) {
            const designs = JSON.parse(localStorage.getItem('wledDesigns')) || {};
            const design = designs[name];
            
            if (!design) {
                showStatus('‚ùå No se encontr√≥ el dise√±o.', true);
                return;
            }

            stopAllAnimations();
            
            const payload_i = [];
            
            for (let i = 0; i < totalLeds; i++) {
                ledColors[i] = '#333333';
                updateLEDVisual(i, '#333333', false);
            }
            
            for(const [index, color] of Object.entries(design)) {
                const rgb = hexToRgb(color);
                const idx = parseInt(index);
                payload_i.push(idx, ...rgb);
                
                ledColors[idx] = color;
                updateLEDVisual(idx, color, false);
            }
            
            ledMeshes.forEach(mesh => {
                mesh.material.needsUpdate = true;
            });

            await sendToWLED({
                "on": true,
                "seg": [{ "fx": 0, "i": payload_i }]
            });
            
            showStatus(`‚úì Dise√±o "${name}" cargado.`);
        }

        function deleteDesign(name) {
            if (!confirm(`¬øSeguro que quieres borrar el dise√±o "${name}"?`)) {
                return;
            }
            let designs = JSON.parse(localStorage.getItem('wledDesigns')) || {};
            delete designs[name];
            localStorage.setItem('wledDesigns', JSON.stringify(designs));
            showStatus(`‚úì Dise√±o "${name}" borrado.`);
            loadDesigns();
        }

        // =====================================================
        // TIMER
        // =====================================================

        function updateClock() {
            const now = new Date();
            const timeString = now.toLocaleTimeString('es-ES', { 
                hour: '2-digit', 
                minute: '2-digit',
                hour12: false
            });
            document.getElementById('currentTime').textContent = timeString;
        }

        function loadTimerSettings() {
            const settings = JSON.parse(localStorage.getItem('wledTimer')) || {};
            document.getElementById('timerEnabled').checked = settings.enabled || false;
            document.getElementById('onTime').value = settings.on || '15:00';
            document.getElementById('offTime').value = settings.off || '07:00';
        }

        async function updateTimer() {
            const settings = {
                enabled: document.getElementById('timerEnabled').checked,
                on: document.getElementById('onTime').value,
                off: document.getElementById('offTime').value
            };
            localStorage.setItem('wledTimer', JSON.stringify(settings));
            
            if (settings.enabled) {
                showStatus('‚úì Timer activado');
            } else {
                showStatus('‚úì Timer desactivado');
            }
        }

        function checkTimer() {
            const settings = JSON.parse(localStorage.getItem('wledTimer')) || {};
            if (!settings.enabled) return;

            const now = new Date();
            const currentHour = now.getHours();
            const currentMin = now.getMinutes();
            const currentTime = currentHour * 60 + currentMin;
            
            const [onH, onM] = settings.on.split(':').map(Number);
            const onTime = onH * 60 + onM;
            
            const [offH, offM] = settings.off.split(':').map(Number);
            const offTime = offH * 60 + offM;
            
            if (Math.abs(currentTime - onTime) < 1) {
                showStatus('‚è∞ Timer: Encendiendo luces');
                updateAllLEDsVisual(selectedColor);
                sendToWLED({"on": true});
            } else if (Math.abs(currentTime - offTime) < 1) {
                showStatus('‚è∞ Timer: Apagando luces');
                updateAllLEDsVisual('#000000');
                sendToWLED({"on": false});
            }
        }
        
        // =====================================================
        // UTILIDADES
        // =====================================================
        
        function generateStars() {
            const starsContainer = document.getElementById('stars');
            for(let i = 0; i < 100; i++) {
                const star = document.createElement('div');
                star.className = 'star';
                star.style.left = Math.random() * 100 + '%';
                star.style.top = Math.random() * 100 + '%';
                star.style.animationDelay = Math.random() * 3 + 's';
                starsContainer.appendChild(star);
            }
        }

        function showStatus(message, isError = false) {
            const oldMessage = document.querySelector('.status-message');
            if (oldMessage) oldMessage.remove();
            
            const status = document.createElement('div');
            status.className = 'status-message';
            status.textContent = message;
            if (isError) {
                status.style.background = '#dc3545';
            }
            document.body.appendChild(status);
            
            setTimeout(() => {
                status.remove();
            }, 3000);
        }

        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : null;
        }

        function rgbToHex(r, g, b) {
            return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
        }

        function hslToRgb(h, s, l) {
            s /= 100;
            l /= 100;
            const k = n => (n + h / 30) % 12;
            const a = s * Math.min(l, 1 - l);
            const f = n => l - a * Math.max(-1, Math.min(k(n) - 3, Math.min(9 - k(n), 1)));
            return {
                r: Math.round(255 * f(0)),
                g: Math.round(255 * f(8)),
                b: Math.round(255 * f(4))
            };
        }
        
        function escapeHTML(str) {
            return str.replace(/[&<>"']/g, function(m) {
                return {
                    '&': '&amp;',
                    '<': '&lt;',
                    '>': '&gt;',
                    '"': '&quot;',
                    "'": '&#39;'
                }[m];
            });
        }

    </script>
</body>
</html>
