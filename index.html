<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üéÑ Christmas LED Tree - 3D WLED Edition</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: radial-gradient(ellipse at bottom, #1b2735 0%, #090a0f 100%);
            overflow: hidden;
            height: 100vh;
            color: #333;
        }
        
        .stars {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        
        .star {
            position: absolute;
            width: 2px;
            height: 2px;
            background: white;
            border-radius: 50%;
            animation: twinkle 3s infinite;
        }
        
        @keyframes twinkle {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 1; }
        }
        
        .main-container {
            display: flex;
            height: 100vh;
            position: relative;
            z-index: 1;
        }
        
        .tree-view {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
            position: relative;
        }
        
        .tree-container {
            position: relative;
            width: 90%;
            height: 90%;
            max-width: 800px;
            max-height: 900px;
        }
        
        #treeCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: grab;
        }
        #treeCanvas:active {
            cursor: grabbing;
        }
        
        /* BOT√ìN SCHEDULE FLOTANTE */
        /* BOT√ìN SCHEDULE MINIMALISTA */
        .schedule-button {
            position: fixed;
            top: 15px;
            right: 470px;
            background: linear-gradient(135deg, #4776E6 0%, #8E54E9 100%);
            color: white;
            border: none;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 10px rgba(71, 118, 230, 0.4);
            transition: all 0.3s;
            z-index: 100;
        }

        .schedule-button span {
            display: none;
            /* Oculta el texto */
        }

        .schedule-button:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 15px rgba(71, 118, 230, 0.6);
        }

        /* Tooltip al pasar el mouse */
        .schedule-button::after {
            content: 'Schedule';
            position: absolute;
            bottom: -30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }

        .schedule-button:hover::after {
            opacity: 1;
        }
        
        /* MODAL DE SCHEDULE */
        .schedule-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            z-index: 1000;
        }
        
        .schedule-modal.active {
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        .schedule-container {
            background: white;
            width: 90%;
            max-width: 1200px;
            height: 85vh;
            border-radius: 20px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            animation: slideUp 0.3s;
        }
        
        @keyframes slideUp {
            from {
                transform: translateY(50px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }
        
        .schedule-header {
            background: linear-gradient(135deg, #4776E6 0%, #8E54E9 100%);
            color: white;
            padding: 20px 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .schedule-header h2 {
            font-size: 24px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .close-schedule {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 24px;
            font-weight: bold;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            line-height: 1;
        }

        .close-schedule:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: rotate(90deg) scale(1.1);
        }

        .close-schedule:active {
            transform: rotate(90deg) scale(0.95);
        }
        
        .schedule-body {
            flex: 1;
            overflow-y: auto;
            padding: 30px;
            background: #f8f9fa;
        }
        
        .schedule-grid {
            display: grid;
            grid-template-columns: 100px 1fr;
            gap: 20px;
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }
        
        .time-column {
            display: flex;
            flex-direction: column;
            gap: 40px;
            padding-top: 40px;
        }
        
        .time-label {
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            padding-right: 10px;
            font-size: 12px;
            color: #666;
            border-top: 1px solid #e0e0e0;
        }
        
        .days-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 10px;
        }
        
        .day-column {
            background: #fff;
            border: 1px solid #e0e0e0;
            border-radius: 10px;
            overflow: hidden;
        }
        
        .day-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 10px;
            text-align: center;
            font-weight: 600;
            font-size: 14px;
        }
        
        .day-schedule {
            position: relative;
            height: 1440px;
            background: repeating-linear-gradient(
                to bottom,
                #fff 0px,
                #fff 59px,
                #f5f5f5 59px,
                #f5f5f5 60px
            
            );
        }
        
        .schedule-block {
            position: absolute;
            left: 5px;
            right: 5px;
            background: #4CAF50;
            color: white;
            border-radius: 5px;
            padding: 5px;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            /* INICIO: Soluci√≥n #2 - Ocultar texto si es muy peque√±o */
            overflow: hidden; 
            /* FIN: Soluci√≥n #2 */
        }
        
        .schedule-block:hover {
            transform: scale(1.02);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
        }
        
        .schedule-block.inactive {
            background: #9e9e9e;
            opacity: 0.7;
        }
        
        .add-schedule-panel {
            background: white;
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }
        
        .quick-actions {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .quick-action-btn {
            flex: 1;
            padding: 10px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
        }
        
        .quick-action-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 10px rgba(102, 126, 234, 0.4);
        }
        
        .control-panel {
            width: 450px;
            background: rgba(255, 255, 255, 0.98);
            overflow-y: auto;
            box-shadow: -5px 0 30px rgba(0,0,0,0.3);
            display: flex;
            flex-direction: column;
        }
        
        .panel-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px 20px; /* Reducido de 20px */
            text-align: center;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .panel-header h1 {
            font-size: 1.5em;
            /* Reducido de 1.8em */
            margin-bottom: 3px;
        }

        .panel-header p {
            font-size: 0.9em;
            /* M√°s peque√±o */
            opacity: 0.9;
        }
        
        .panel-content {
            padding: 20px;
            flex-grow: 1;
        }
        
        .section {
            background: white;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .section-title {
            font-size: 1.1em;
            font-weight: 600;
            color: #333;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .connection-status {
            padding: 10px;
            border-radius: 8px;
            text-align: center;
            font-weight: 600;
            margin-bottom: 15px;
        }
        
        .connection-status.connected {
            background: #d4edda;
            color: #155724;
        }
        
        .connection-status.disconnected {
            background: #f8d7da;
            color: #721c24;
        }
        
        .connection-status.connecting {
            background: #fff3cd;
            color: #856404;
        }
        
        .info-box {
            background: #e7f3ff;
            border-left: 4px solid #2196F3;
            padding: 12px;
            margin-bottom: 15px;
            border-radius: 4px;
            font-size: 13px;
        }
        
        .debug-log {
            background: #f5f5f5;
            border: 1px solid #ddd;
            border-radius: 6px;
            padding: 10px;
            max-height: 200px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            margin-top: 10px;
        }
        
        .debug-log div {
            margin: 2px 0;
            padding: 2px;
        }
        
        .debug-log .success {
            color: #28a745;
        }
        
        .debug-log .error {
            color: #dc3545;
        }
        
        .debug-log .info {
            color: #007bff;
        }
        
        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s;
            width: 100%;
            margin-bottom: 10px;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        button:active {
            transform: translateY(0);
            box-shadow: 0 2px 6px rgba(102, 126, 234, 0.3);
        }
        
        button.active {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            box-shadow: 0 0 20px rgba(79, 172, 254, 0.6);
        }
        
        button.danger {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }
        button.danger:hover {
            box-shadow: 0 4px 12px rgba(245, 87, 108, 0.4);
        }
        
        .color-selector {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-bottom: 15px;
        }
        
        input[type="color"] {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            width: 60px;
            height: 60px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            padding: 0;
            background-color: transparent;
        }
        input[type="color"]::-webkit-color-swatch-wrapper {
            padding: 0;
            border: 3px solid #ddd;
            border-radius: 8px;
        }
        input[type="color"]::-webkit-color-swatch {
            border: none;
            border-radius: 5px;
        }
        input[type="color"]::-moz-color-swatch {
            border: none;
            border-radius: 5px;
        }
        
        .brightness-control {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 15px 0;
        }
        
        input[type="range"] {
            flex: 1;
            height: 8px;
            border-radius: 5px;
            background: #ddd;
            outline: none;
            -webkit-appearance: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
        }
        
        .brightness-value {
            min-width: 50px;
            text-align: right;
            font-weight: 600;
            color: #667eea;
        }
        
        input[type="text"], input[type="time"] {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 14px;
            margin-bottom: 10px;
            transition: border 0.3s;
        }
        
        input[type="text"]:focus, input[type="time"]:focus {
            outline: none;
            border-color: #667eea;
        }
        
        .effects-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }
        
        .effect-btn {
            margin: 0;
            padding: 10px;
            font-size: 13px;
        }
        
        .color-palette {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 8px;
            margin-top: 10px;
        }
        
        .palette-color {
            width: 100%;
            aspect-ratio: 1;
            border-radius: 8px;
            cursor: pointer;
            border: 3px solid transparent;
            transition: all 0.3s;
        }
        
        .palette-color:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }
        
        .palette-color.selected {
            border-color: #667eea;
            transform: scale(1.1);
        }
        
        .design-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 8px;
            margin-bottom: 8px;
        }
        
        .design-item button {
            width: auto;
            margin: 0 5px;
            padding: 8px 15px;
        }
        
        .delete-btn {
            background: #dc3545 !important;
            padding: 8px 12px !important;
        }
        
        .status-message {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #28a745;
            color: white;
            padding: 15px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            z-index: 1000;
            animation: slideIn 0.3s;
        }
        
        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        
        .animated-effects-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }
        
        .animated-effects-grid button {
            margin: 0;
            padding: 10px;
            font-size: 13px;
        }
        
        .animated-effects-grid button:last-child {
            grid-column: 1 / -1;
        }
        
        @media (max-width: 1024px) {
            .main-container {
                flex-direction: column;
            }
            
            .control-panel {
                width: 100%;
                max-height: 50vh;
            }
            
            .tree-view {
                height: 50vh;
            }
            
            .schedule-button {
                right: 20px;
            }
        }

        /* INICIO: Soluci√≥n #4 - Responsividad del Modal Schedule */
        @media (max-width: 768px) {
            
            /* Hacer el modal full-screen en m√≥vil */
            .schedule-container {
                width: 100vw;
                height: 100vh;
                max-width: 100vw;
                max-height: 100vh;
                height: 100%;
                border-radius: 0;
            }

            .schedule-header h2 {
                font-size: 18px;
                gap: 5px;
            }

            .close-schedule {
                width: 35px;
                height: 35px;
                font-size: 20px;
            }

            .schedule-body {
                padding: 10px;
            }

            /* Apilar acciones r√°pidas verticalmente */
            .quick-actions {
                flex-direction: column;
                gap: 8px;
            }

            .add-schedule-panel {
                padding: 15px;
            }

            /* Forzar que los selectores de d√≠a se envuelvan */
            [style*="grid-template-columns: repeat(7, 1fr)"] {
                grid-template-columns: repeat(4, 1fr) !important;
                gap: 10px !important;
            }

            /* Apilar Inicio, Fin y Bot√≥n de agregar */
            [style*="grid-template-columns: 1fr 1fr auto"] {
                grid-template-columns: 1fr !important;
                gap: 15px !important;
            }
            [style*="grid-template-columns: 1fr 1fr auto"] button {
                width: 100% !important;
            }


            /* Hacer que la grilla de d√≠as tenga scroll horizontal */
            .schedule-grid {
                grid-template-columns: 60px 1fr; /* Reducir columna de hora */
                gap: 10px;
                padding: 10px;
                /* Permitir que la grilla se desborde */
                overflow-x: auto;
            }

            .time-column {
                gap: 40px; /* Mantener alineaci√≥n */
            }

            .time-label {
                font-size: 10px;
                padding-right: 5px;
            }

            .days-grid {
                /* Forzar las 7 columnas, pero permitir scroll */
                grid-template-columns: repeat(7, 120px); /* Ancho fijo para cada d√≠a */
                gap: 5px;
            }

            .day-header {
                font-size: 12px;
            }
        }
        /* FIN: Soluci√≥n #4 */

        /* =====================================================
           ESTILOS DE AUTENTICACI√ìN
           ===================================================== */

        .auth-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            opacity: 1;
            transition: opacity 0.3s ease;
        }

        .auth-overlay.hidden {
            display: none;
            opacity: 0;
        }

        .auth-container {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            width: 90%;
            max-width: 420px;
            padding: 40px;
            position: relative;
            animation: slideIn 0.4s ease-out;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-30px) scale(0.95);
            }
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        .auth-header {
            text-align: center;
            margin-bottom: 30px;
        }

        .auth-header h2 {
            color: white;
            font-size: 28px;
            margin-bottom: 8px;
            font-weight: 600;
        }

        .auth-header p {
            color: rgba(255, 255, 255, 0.8);
            font-size: 14px;
        }

        .auth-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 25px;
            background: rgba(255, 255, 255, 0.1);
            padding: 5px;
            border-radius: 12px;
        }

        .auth-tab {
            flex: 1;
            padding: 12px;
            border: none;
            background: transparent;
            color: rgba(255, 255, 255, 0.7);
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            border-radius: 10px;
            transition: all 0.3s;
        }

        .auth-tab.active {
            background: white;
            color: #667eea;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .auth-form {
            display: none;
        }

        .auth-form.active {
            display: block;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            color: white;
            font-size: 13px;
            font-weight: 500;
            margin-bottom: 8px;
        }

        .form-group input {
            width: 100%;
            padding: 14px 16px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            background: rgba(255, 255, 255, 0.9);
            font-size: 15px;
            transition: all 0.3s;
            box-sizing: border-box;
        }

        .form-group input:focus {
            outline: none;
            border-color: white;
            background: white;
            box-shadow: 0 0 0 3px rgba(255, 255, 255, 0.2);
        }

        .password-strength {
            margin-top: 8px;
            font-size: 12px;
            display: none;
        }

        .password-strength.show {
            display: block;
        }

        .strength-bar {
            height: 4px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 2px;
            margin-bottom: 5px;
            overflow: hidden;
        }

        .strength-fill {
            height: 100%;
            width: 0%;
            transition: all 0.3s;
            border-radius: 2px;
        }

        .strength-fill.weak {
            width: 33%;
            background: #ff4444;
        }

        .strength-fill.medium {
            width: 66%;
            background: #ffaa00;
        }

        .strength-fill.strong {
            width: 100%;
            background: #00C851;
        }

        .strength-text {
            color: white;
            font-weight: 500;
        }

        .error-message {
            background: rgba(255, 68, 68, 0.2);
            border: 1px solid rgba(255, 68, 68, 0.5);
            color: white;
            padding: 12px;
            border-radius: 10px;
            margin-bottom: 15px;
            font-size: 13px;
            display: none;
        }

        .error-message.show {
            display: block;
        }

        .success-message {
            background: rgba(0, 200, 81, 0.2);
            border: 1px solid rgba(0, 200, 81, 0.5);
            color: white;
            padding: 12px;
            border-radius: 10px;
            margin-bottom: 15px;
            font-size: 13px;
            display: none;
        }

        .success-message.show {
            display: block;
        }

        .auth-button {
            width: 100%;
            padding: 15px;
            border: none;
            border-radius: 12px;
            background: white;
            color: #667eea;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            margin-bottom: 15px;
        }

        .auth-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.2);
        }

        .auth-button:active {
            transform: translateY(0);
        }

        .auth-button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .auth-divider {
            text-align: center;
            color: rgba(255, 255, 255, 0.7);
            font-size: 13px;
            margin: 25px 0;
            position: relative;
        }

        .auth-divider::before,
        .auth-divider::after {
            content: '';
            position: absolute;
            top: 50%;
            width: 40%;
            height: 1px;
            background: rgba(255, 255, 255, 0.3);
        }

        .auth-divider::before {
            left: 0;
        }

        .auth-divider::after {
            right: 0;
        }

        .oauth-buttons {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .oauth-button {
            width: 100%;
            padding: 14px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 12px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 15px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        .oauth-button:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: white;
            transform: translateY(-2px);
        }

        .oauth-button:active {
            transform: translateY(0);
        }

        .forgot-password {
            text-align: center;
            margin-top: 15px;
        }

        .forgot-password a {
            color: white;
            font-size: 13px;
            text-decoration: none;
            opacity: 0.8;
            transition: opacity 0.3s;
        }

        .forgot-password a:hover {
            opacity: 1;
            text-decoration: underline;
        }

        /* Responsive para m√≥viles */
        @media (max-width: 768px) {
            .auth-container {
                width: 95%;
                padding: 30px 20px;
            }

            .auth-header h2 {
                font-size: 24px;
            }

            .form-group input {
                padding: 12px 14px;
                font-size: 16px; /* Evita zoom en iOS */
            }

            .auth-button {
                padding: 14px;
                font-size: 15px;
            }

            .oauth-button {
                padding: 12px;
                font-size: 14px;
            }
        }

        /* Animaci√≥n de carga */
        .auth-loading {
            display: inline-block;
            width: 18px;
            height: 18px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

    </style>

    <!-- Supabase SDK -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
</head>
<body>
    <div id="stars" class="stars"></div>

    <!-- Modal de Autenticaci√≥n -->
    <div id="authOverlay" class="auth-overlay">
        <div class="auth-container">
            <div class="auth-header">
                <h2>üéÑ Christmas Tree LED</h2>
                <p>Inicia sesi√≥n para controlar tus luces</p>
            </div>

            <!-- Tabs -->
            <div class="auth-tabs">
                <button class="auth-tab active" onclick="switchAuthTab('login')">Iniciar Sesi√≥n</button>
                <button class="auth-tab" onclick="switchAuthTab('register')">Registrarse</button>
            </div>

            <!-- Mensajes de error y √©xito -->
            <div id="authError" class="error-message"></div>
            <div id="authSuccess" class="success-message"></div>

            <!-- Formulario de Login -->
            <form id="loginForm" class="auth-form active" onsubmit="handleLogin(event)">
                <div class="form-group">
                    <label for="loginEmail">üìß Correo Electr√≥nico</label>
                    <input
                        type="email"
                        id="loginEmail"
                        placeholder="tu@email.com"
                        required
                        autocomplete="email"
                    >
                </div>

                <div class="form-group">
                    <label for="loginPassword">üîí Contrase√±a</label>
                    <input
                        type="password"
                        id="loginPassword"
                        placeholder="Tu contrase√±a"
                        required
                        autocomplete="current-password"
                    >
                </div>

                <button type="submit" class="auth-button" id="loginButton">
                    Iniciar Sesi√≥n
                </button>

                <div class="forgot-password">
                    <a href="#" onclick="handleForgotPassword(); return false;">¬øOlvidaste tu contrase√±a?</a>
                </div>
            </form>

            <!-- Formulario de Registro -->
            <form id="registerForm" class="auth-form" onsubmit="handleRegister(event)">
                <div class="form-group">
                    <label for="registerEmail">üìß Correo Electr√≥nico</label>
                    <input
                        type="email"
                        id="registerEmail"
                        placeholder="tu@email.com"
                        required
                        autocomplete="email"
                    >
                </div>

                <div class="form-group">
                    <label for="registerPassword">üîí Contrase√±a</label>
                    <input
                        type="password"
                        id="registerPassword"
                        placeholder="M√≠nimo 8 caracteres"
                        required
                        autocomplete="new-password"
                        oninput="checkPasswordStrength(this.value)"
                    >
                    <div id="passwordStrength" class="password-strength">
                        <div class="strength-bar">
                            <div id="strengthFill" class="strength-fill"></div>
                        </div>
                        <div id="strengthText" class="strength-text"></div>
                    </div>
                </div>

                <div class="form-group">
                    <label for="registerPasswordConfirm">üîí Confirmar Contrase√±a</label>
                    <input
                        type="password"
                        id="registerPasswordConfirm"
                        placeholder="Repite tu contrase√±a"
                        required
                        autocomplete="new-password"
                    >
                </div>

                <button type="submit" class="auth-button" id="registerButton">
                    Crear Cuenta
                </button>
            </form>

            <!-- Divider -->
            <div class="auth-divider">o usa Google</div>

            <!-- OAuth Buttons -->
            <div class="oauth-buttons">
                <button class="oauth-button" onclick="handleOAuthLogin('google')">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z" fill="#4285F4"/>
                        <path d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z" fill="#34A853"/>
                        <path d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z" fill="#FBBC05"/>
                        <path d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z" fill="#EA4335"/>
                    </svg>
                    Continuar con Google
                </button>
            </div>
        </div>
    </div>

    <button class="schedule-button" onclick="openSchedule()">
        üìÖ <span style="font-size: 12px;">Schedule</span>
    </button>
    
    <div id="scheduleModal" class="schedule-modal">
        <div class="schedule-container">
            <div class="schedule-header">
                <h2>üìÖ Programaci√≥n de Horarios LED</h2>
                <button class="close-schedule" onclick="closeSchedule()" aria-label="Cerrar">‚úï</button>
            </div>
            
            <div class="schedule-body">
                <div class="add-schedule-panel">
                    <h3 style="margin-bottom: 15px; color: #667eea;">‚ö° Acciones R√°pidas</h3>
                    <div class="quick-actions">
                        <button class="quick-action-btn" onclick="setWeekdaySchedule()">
                             üíº Lun-Vie (7:00-21:00)
                        </button>
                        <button class="quick-action-btn" onclick="setWeekendSchedule()">
                            üèñÔ∏è Fin de Semana (9:00-23:00)
                        </button>
                        <button class="quick-action-btn" onclick="setEveningSchedule()">
                            üåô Solo Tardes (17:00-23:00)
                        </button>
                        <button class="quick-action-btn" onclick="clearAllSchedules()" style="background: #dc3545;">
                            üóëÔ∏è Limpiar Todo
                        </button>
                    </div>
    
                    
                    <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin-top: 15px;">
                        <h4 style="margin-top: 0; color: #667eea;">‚ûï Agregar Horario Personalizado</h4>
                        
                        <div style="display: grid; grid-template-columns: repeat(7, 1fr); gap: 5px; margin-bottom: 15px;">
                            <label style="display: flex; align-items: center; font-size: 13px;">
                                <input type="checkbox" id="day-0" style="margin-right: 3px;"> Dom
                            </label>
                            <label style="display: flex; align-items: center; font-size: 13px;">
                                <input type="checkbox" id="day-1" style="margin-right: 3px;"> Lun
                            </label>
                            <label style="display: flex; align-items: center; font-size: 13px;">
                                <input type="checkbox" id="day-2" style="margin-right: 3px;"> Mar
                            </label>
                            <label style="display: flex; align-items: center; font-size: 13px;">
                                <input type="checkbox" id="day-3" style="margin-right: 3px;"> Mi√©
                            </label>
                            <label style="display: flex; align-items: center; font-size: 13px;">
                                <input type="checkbox" id="day-4" style="margin-right: 3px;"> Jue
                            </label>
                            <label style="display: flex; align-items: center; font-size: 13px;">
                                <input type="checkbox" id="day-5" style="margin-right: 3px;"> Vie
                            </label>
                            <label style="display: flex; align-items: center; font-size: 13px;">
                                <input type="checkbox" id="day-6" style="margin-right: 3px;"> S√°b
                            </label>
                        </div>
        
                        
                        <div style="display: grid; grid-template-columns: 1fr 1fr auto; gap: 10px; align-items: end;">
                            <div>
                                <label style="font-size: 12px; color: #666;">Hora Inicio:</label>
                                <input type="time" id="scheduleStartTime" value="07:00" style="margin: 0;">
                            </div>
                            <div>
                                 <label style="font-size: 12px; color: #666;">Hora Fin:</label>
                                <input type="time" id="scheduleEndTime" value="21:00" style="margin: 0;">
                            </div>
                            <button onclick="addSchedule()" style="background: #28a745; margin: 0; width: auto; padding: 10px 20px;">
                                ‚ûï Agregar
                            </button>
                        </div>
                    </div>
                    
                    <div style="margin-top: 20px; padding: 15px; background: #e7f3ff; border-radius: 8px; border-left: 4px solid #2196F3;">
                        <label style="display: flex; align-items: center; gap: 10px; font-weight: 600;">
                            <input type="checkbox" id="schedulerEnabled" onchange="updateScheduler()" style="width: 20px; height: 20px;">
                            <span>üîå Activar Programaci√≥n Autom√°tica</span>
                        </label>
                        <p style="margin-top: 10px; margin-bottom: 10px; font-size: 13px; color: #666;">
                            Estado: <span id="scheduleStatusText" style="font-weight: 600;">Desactivado</span>
                        </p>
                        <div style="margin-top: 10px;">
                            <label style="font-size: 12px; color: #666; display: block; margin-bottom: 5px;">üåç Zona Horaria:</label>
                            <select id="timezoneSelect" onchange="saveTimezone()" style="width: 100%; padding: 8px; border-radius: 4px; border: 1px solid #ccc;">
                                <option value="America/Santo_Domingo">Am√©rica/Santo Domingo (AST, UTC-4)</option>
                                <option value="America/New_York">Am√©rica/New York (EST/EDT, UTC-5/-4)</option>
                                <option value="America/Chicago">Am√©rica/Chicago (CST/CDT, UTC-6/-5)</option>
                                <option value="America/Denver">Am√©rica/Denver (MST/MDT, UTC-7/-6)</option>
                                <option value="America/Los_Angeles">Am√©rica/Los Angeles (PST/PDT, UTC-8/-7)</option>
                                <option value="America/Mexico_City">Am√©rica/Ciudad de M√©xico (CST/CDT, UTC-6/-5)</option>
                                <option value="America/Bogota">Am√©rica/Bogot√° (COT, UTC-5)</option>
                                <option value="America/Lima">Am√©rica/Lima (PET, UTC-5)</option>
                                <option value="America/Argentina/Buenos_Aires">Am√©rica/Buenos Aires (ART, UTC-3)</option>
                                <option value="America/Sao_Paulo">Am√©rica/S√£o Paulo (BRT, UTC-3)</option>
                                <option value="Europe/Madrid">Europa/Madrid (CET/CEST, UTC+1/+2)</option>
                                <option value="Europe/London">Europa/Londres (GMT/BST, UTC+0/+1)</option>
                                <option value="Asia/Tokyo">Asia/Tokio (JST, UTC+9)</option>
                                <option value="UTC">UTC (UTC+0)</option>
                            </select>
                        </div>
                    </div>
                </div>
   
                 
                <div class="schedule-grid">
                    <div class="time-column">
                        <div class="time-label">00:00</div>
                         <div class="time-label">02:00</div>
                        <div class="time-label">04:00</div>
                        <div class="time-label">06:00</div>
                        <div class="time-label">08:00</div>
                         <div class="time-label">10:00</div>
                        <div class="time-label">12:00</div>
                        <div class="time-label">14:00</div>
                        <div class="time-label">16:00</div>
                         <div class="time-label">18:00</div>
                        <div class="time-label">20:00</div>
                        <div class="time-label">22:00</div>
                    </div>
                       
                    <div class="days-grid" id="scheduleGrid">
                        </div>
                </div>
            </div>
        </div>
    </div>
    
    <div class="main-container">
        <div class="tree-view">
            <div class="tree-container">
                <canvas id="treeCanvas"></canvas>
            </div>
        </div>
        
   
         <div class="control-panel">
            <div class="panel-header">
                <h1>üéÑ Christmas LED Tree</h1>
                <p>¬© 2024 AMSC All rights reserved.</p>
            </div>

            <!-- User Info y Logout -->
            <div id="userInfo" style="display: none; padding: 10px 20px; background: rgba(102, 126, 234, 0.1); border-bottom: 1px solid rgba(102, 126, 234, 0.2); text-align: center;">
                <div style="font-size: 12px; color: #666; margin-bottom: 5px;">
                    Sesi√≥n activa: <span id="userEmail" style="color: #667eea; font-weight: 500;"></span>
                </div>
                <button onclick="handleLogout()" style="padding: 6px 16px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 12px; font-weight: 500; transition: all 0.3s;">
                    üö™ Cerrar Sesi√≥n
                </button>
            </div>

            <div class="panel-content">
     
                <div class="section">
                    <div class="section-title">üîå Conexi√≥n MQTT</div>
                    
                    <div class="connection-status connecting" id="connectionStatus">
                         üîÑ Conectando...
                    </div>
                    
                    <div class="info-box">
                         <strong>üì° Servidor:</strong> mqtt.vittence.com<br>
                        <strong>üîí Protocolo:</strong> WebSocket Secure (WSS) - Puerto 8084<br>
                        <strong>üéØ Topic:</strong> wled/tree/api<br>
                        <strong>‚úÖ SSL:</strong> Certificado Let's Encrypt v√°lido<br>
                         <strong>üåê Compatible:</strong> Funciona desde HTTPS
                    </div>
                    
                    <button onclick="reconnectMQTT()">üîÑ Reconectar MQTT</button>
                     <button onclick="sendTestMessage()">üì§ Enviar Mensaje de Prueba</button>
                    <button onclick="resetWLED()" class="danger">üî¥ Apagar LEDs</button>
                    
                    <div class="debug-log" id="debugLog"></div>
                </div>
               
                <div class="section">
                    <div class="section-title">üé® LED Color</div>
                    <div class="color-selector">
                         <input type="color" id="ledColor" value="#ff0000" onchange="updateSelectedColor()">
                        <button onclick="activatePaintMode()" id="paintBtn">Activar Paint Mode</button>
                    </div>
                    
                     <div id="colorPalette" class="color-palette" style="display: none;">
                        <div class="palette-color selected" style="background: #ff0000" onclick="selectPaletteColor('#ff0000')"></div>
                        <div class="palette-color" style="background: #ffa500" onclick="selectPaletteColor('#ffa500')"></div>
                        <div class="palette-color" style="background: #ffff00" onclick="selectPaletteColor('#ffff00')"></div>
                         <div class="palette-color" style="background: #ffffff" onclick="selectPaletteColor('#ffffff')"></div>
                        <div class="palette-color" style="background: #00ff00" onclick="selectPaletteColor('#00ff00')"></div>
                        <div class="palette-color" style="background: #0000ff" onclick="selectPaletteColor('#0000ff')"></div>
                         <div class="palette-color" style="background: #4b0082" onclick="selectPaletteColor('#4b0082')"></div>
                        <div class="palette-color" style="background: #ee82ee" onclick="selectPaletteColor('#ee82ee')"></div>
                        <div class="palette-color" style="background: #333333" onclick="selectPaletteColor('#333333')"></div>
                    </div>
                </div>
 
                <div class="section">
                    <div class="section-title">üí° Brightness</div>
                    <div class="brightness-control">
                         <input type="range" id="brightness" min="0" max="255" value="128" oninput="setBrightness(this.value)">
                        <span class="brightness-value" id="brightVal">50%</span>
                    </div>
                </div>

                <!-- Control B√°sico -->
                <div class="section">
                    <div class="section-title">‚ö° Control</div>
                    <div class="effects-grid">
                        <button class="effect-btn" onclick="setStaticDesign('OFF')" style="background: #dc3545;">üî¥ OFF</button>
                        <button class="effect-btn" onclick="runEffect(0)">‚ö™ Solid (Static)</button>
                    </div>
                </div>

                <!-- Color Palettes -->
                <div class="section">
                    <div class="section-title">üé® Color Palettes</div>
                    <div class="effects-grid">
                        <button class="effect-btn" onclick="setPalette(2)">üíú Purple Rain</button>
                        <button class="effect-btn" onclick="setPalette(255)">üá©üá¥ Dominican</button>
                        <button class="effect-btn" onclick="setPalette(35)">üî• Fire</button>
                        <button class="effect-btn" onclick="setPalette(9)">üåä Ocean</button>
                        <button class="effect-btn" onclick="setPalette(8)">üåã Lava</button>
                        <button class="effect-btn" onclick="setPalette(11)">üåà Rainbow</button>
                        <button class="effect-btn" onclick="setPalette(10)">üå≤ Forest</button>
                        <button class="effect-btn" onclick="setPalette(13)">üåÖ Sunset</button>
                        <button class="effect-btn" onclick="setPalette(26)">üèñÔ∏è Beach</button>
                        <button class="effect-btn" onclick="setPalette(6)">üéâ Party</button>
                        <button class="effect-btn" onclick="setPalette(20)">üå∏ Pastel</button>
                        <button class="effect-btn" onclick="setPalette(7)">‚òÅÔ∏è Cloud</button>
                        <button class="effect-btn" onclick="setPalette(50)">‚ú® Aurora</button>
                        <button class="effect-btn" onclick="setPalette(48)">üéÑ C9 (Christmas)</button>
                    </div>
                </div>

                <!-- Effect Modes -->
                <div class="section">
                    <div class="section-title">‚ö° Effect Modes</div>
                    <div class="effects-grid">
                        <button class="effect-btn" onclick="runEffect(1)">üí´ Blink</button>
                        <button class="effect-btn" onclick="runEffect(2)">üå¨Ô∏è Breathe</button>
                        <button class="effect-btn" onclick="runEffect(9)">üåà Rainbow</button>
                        <button class="effect-btn" onclick="runEffect(10)">üì° Scan</button>
                        <button class="effect-btn" onclick="runEffect(17)">‚ú® Twinkle</button>
                        <button class="effect-btn" onclick="runEffect(20)">‚≠ê Sparkle</button>
                        <button class="effect-btn" onclick="runEffect(28)">üèÉ Chase</button>
                        <button class="effect-btn" onclick="runEffect(38)">üåå Aurora</button>
                        <button class="effect-btn" onclick="runEffect(42)">üéÜ Fireworks</button>
                        <button class="effect-btn" onclick="runEffect(45)">üåã Lava</button>
                        <button class="effect-btn" onclick="runEffect(67)">üåÄ Colorwaves</button>
                        <button class="effect-btn" onclick="runEffect(76)">‚òÑÔ∏è Meteor</button>
                        <button class="effect-btn" onclick="runEffect(79)">üíß Ripple</button>
                        <button class="effect-btn" onclick="runEffect(101)">üå¥ Pacifica</button>
                        <button class="effect-btn" onclick="runEffect(110)">üé® Flow</button>
                    </div>
                </div>

                <div class="section">
                    <div class="section-title">üìÅ Saved Designs</div>
                     <input type="text" id="designName" placeholder="Design name">
                    <button onclick="saveDesign()">üíæ Save Current Design</button>
                    <div id="designsList"></div>
                </div>
            </div>
        </div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/mqtt@4.3.7/dist/mqtt.min.js"></script>
    
    <script>
        // =====================================================
        // AUTENTICACI√ìN CON SUPABASE
        // =====================================================

        // Inicializar Supabase
        const SUPABASE_URL = 'https://mcwsdinbxwfomkgtolhf.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im1jd3NkaW5ieHdmb21rZ3RvbGhmIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjI2NjU2MzcsImV4cCI6MjA3ODI0MTYzN30.rjJpb2OQRui-1uIsn2VwE_zX-I5V2CKgM3MveZSXxW4';

        // Use different variable name to avoid conflict with window.supabase
        let supabaseClient = null;

        function initSupabase() {
            if (window.supabase && window.supabase.createClient) {
                supabaseClient = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
                console.log('‚úÖ Supabase client initialized');
                return true;
            } else {
                console.error('‚ùå Supabase SDK not loaded');
                return false;
            }
        }

        let currentUser = null;
        let authInitialized = false;

        // =====================================================
        // FUNCIONES DE CAMBIO DE TAB
        // =====================================================

        function switchAuthTab(tab) {
            // Cambiar tabs activos
            document.querySelectorAll('.auth-tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.auth-form').forEach(f => f.classList.remove('active'));

            if (tab === 'login') {
                document.querySelector('.auth-tab:first-child').classList.add('active');
                document.getElementById('loginForm').classList.add('active');
            } else {
                document.querySelector('.auth-tab:last-child').classList.add('active');
                document.getElementById('registerForm').classList.add('active');
            }

            // Limpiar mensajes
            hideAuthMessages();
        }

        // =====================================================
        // VALIDACI√ìN DE CONTRASE√ëA FUERTE
        // =====================================================

        function checkPasswordStrength(password) {
            const strengthIndicator = document.getElementById('passwordStrength');
            const strengthFill = document.getElementById('strengthFill');
            const strengthText = document.getElementById('strengthText');

            if (!password) {
                strengthIndicator.classList.remove('show');
                return { strength: 'none', valid: false };
            }

            strengthIndicator.classList.add('show');

            let strength = 0;
            let feedback = [];

            // Criterios de contrase√±a fuerte
            if (password.length >= 8) strength++;
            else feedback.push('M√≠nimo 8 caracteres');

            if (password.length >= 12) strength++;

            if (/[a-z]/.test(password) && /[A-Z]/.test(password)) strength++;
            else feedback.push('May√∫sculas y min√∫sculas');

            if (/[0-9]/.test(password)) strength++;
            else feedback.push('Al menos un n√∫mero');

            if (/[^a-zA-Z0-9]/.test(password)) strength++;
            else feedback.push('Al menos un s√≠mbolo (!@#$%^&*)');

            // Actualizar visualizaci√≥n
            strengthFill.className = 'strength-fill';

            if (strength <= 2) {
                strengthFill.classList.add('weak');
                strengthText.textContent = '‚ùå D√©bil: ' + feedback.join(', ');
                return { strength: 'weak', valid: false };
            } else if (strength <= 4) {
                strengthFill.classList.add('medium');
                strengthText.textContent = '‚ö†Ô∏è Media: ' + (feedback.length > 0 ? feedback.join(', ') : 'A√±ade s√≠mbolos para mayor seguridad');
                return { strength: 'medium', valid: true };
            } else {
                strengthFill.classList.add('strong');
                strengthText.textContent = '‚úÖ Fuerte: Contrase√±a segura';
                return { strength: 'strong', valid: true };
            }
        }

        // =====================================================
        // FUNCIONES DE AUTENTICACI√ìN
        // =====================================================

        function showAuthError(message) {
            const errorDiv = document.getElementById('authError');
            errorDiv.textContent = message;
            errorDiv.classList.add('show');
            setTimeout(() => errorDiv.classList.remove('show'), 5000);
        }

        function showAuthSuccess(message) {
            const successDiv = document.getElementById('authSuccess');
            successDiv.textContent = message;
            successDiv.classList.add('show');
            setTimeout(() => successDiv.classList.remove('show'), 5000);
        }

        function hideAuthMessages() {
            document.getElementById('authError').classList.remove('show');
            document.getElementById('authSuccess').classList.remove('show');
        }

        // REGISTRO
        async function handleRegister(event) {
            event.preventDefault();
            hideAuthMessages();

            const email = document.getElementById('registerEmail').value;
            const password = document.getElementById('registerPassword').value;
            const passwordConfirm = document.getElementById('registerPasswordConfirm').value;

            // Validar que las contrase√±as coincidan
            if (password !== passwordConfirm) {
                showAuthError('‚ùå Las contrase√±as no coinciden');
                return;
            }

            // Validar fortaleza de contrase√±a
            const passwordCheck = checkPasswordStrength(password);
            if (!passwordCheck.valid) {
                showAuthError('‚ùå La contrase√±a no es lo suficientemente fuerte');
                return;
            }

            // Deshabilitar bot√≥n y mostrar loading
            const button = document.getElementById('registerButton');
            button.disabled = true;
            button.innerHTML = '<span class="auth-loading"></span> Creando cuenta...';

            // VERIFICAR L√çMITE DE USUARIOS (m√°ximo 3)
            try {
                const { data: userCount, error: countError } = await supabaseClient.rpc('count_registered_users');

                if (countError) {
                    console.error('Error al verificar l√≠mite de usuarios:', countError);
                    showAuthError('‚ùå Error al verificar disponibilidad. Por favor, aseg√∫rate de haber configurado la funci√≥n SQL en Supabase (ver SUPABASE_SETUP.md)');
                    button.disabled = false;
                    button.textContent = 'Crear Cuenta';
                    return;
                }

                if (userCount >= 3) {
                    showAuthError('üö´ L√≠mite de usuarios alcanzado. Solo se permiten 3 usuarios registrados.');
                    button.disabled = false;
                    button.textContent = 'Crear Cuenta';
                    return;
                }
            } catch (e) {
                console.error('Error al verificar l√≠mite:', e);
                showAuthError('‚ùå Error al verificar disponibilidad. Verifica la configuraci√≥n de Supabase.');
                button.disabled = false;
                button.textContent = 'Crear Cuenta';
                return;
            }

            try {
                // Usar la URL completa actual (sin hash ni query params)
                const currentUrl = window.location.origin + window.location.pathname;

                const { data, error } = await supabaseClient.auth.signUp({
                    email: email,
                    password: password,
                    options: {
                        emailRedirectTo: currentUrl
                    }
                });

                if (error) throw error;

                if (data.user && !data.user.confirmed_at) {
                    showAuthSuccess('‚úÖ Cuenta creada! Por favor, revisa tu correo para confirmar tu cuenta.');
                } else {
                    showAuthSuccess('‚úÖ Cuenta creada exitosamente!');
                    setTimeout(() => switchAuthTab('login'), 2000);
                }

                // Limpiar formulario
                document.getElementById('registerForm').reset();
                document.getElementById('passwordStrength').classList.remove('show');

            } catch (error) {
                console.error('Error en registro:', error);
                showAuthError('‚ùå ' + (error.message || 'Error al crear la cuenta'));
            } finally {
                button.disabled = false;
                button.textContent = 'Crear Cuenta';
            }
        }

        // LOGIN
        async function handleLogin(event) {
            event.preventDefault();
            hideAuthMessages();

            const email = document.getElementById('loginEmail').value;
            const password = document.getElementById('loginPassword').value;

            const button = document.getElementById('loginButton');
            button.disabled = true;
            button.innerHTML = '<span class="auth-loading"></span> Iniciando sesi√≥n...';

            try {
                const { data, error } = await supabaseClient.auth.signInWithPassword({
                    email: email,
                    password: password
                });

                if (error) throw error;

                if (data.user) {
                    showAuthSuccess('‚úÖ Bienvenido de vuelta!');
                    currentUser = data.user;

                    // Ocultar modal de autenticaci√≥n y mostrar aplicaci√≥n
                    setTimeout(() => {
                        document.getElementById('authOverlay').classList.add('hidden');
                        document.getElementById('loginForm').reset();
                    }, 1000);
                }

            } catch (error) {
                console.error('Error en login:', error);
                if (error.message.includes('Email not confirmed')) {
                    showAuthError('‚ùå Por favor, confirma tu correo electr√≥nico antes de iniciar sesi√≥n');
                } else if (error.message.includes('Invalid login credentials')) {
                    showAuthError('‚ùå Correo o contrase√±a incorrectos');
                } else {
                    showAuthError('‚ùå ' + (error.message || 'Error al iniciar sesi√≥n'));
                }
            } finally {
                button.disabled = false;
                button.textContent = 'Iniciar Sesi√≥n';
            }
        }

        // LOGOUT
        async function handleLogout() {
            try {
                const { error } = await supabaseClient.auth.signOut();
                if (error) throw error;

                currentUser = null;
                document.getElementById('authOverlay').classList.remove('hidden');

            } catch (error) {
                console.error('Error al cerrar sesi√≥n:', error);
            }
        }

        // FORGOT PASSWORD
        async function handleForgotPassword() {
            const email = prompt('Ingresa tu correo electr√≥nico para recuperar tu contrase√±a:');

            if (!email) return;

            try {
                // Usar la URL completa actual (sin hash ni query params)
                const currentUrl = window.location.origin + window.location.pathname;

                const { error } = await supabaseClient.auth.resetPasswordForEmail(email, {
                    redirectTo: currentUrl
                });

                if (error) throw error;

                showAuthSuccess('‚úÖ Se ha enviado un enlace de recuperaci√≥n a tu correo');

            } catch (error) {
                console.error('Error al recuperar contrase√±a:', error);
                showAuthError('‚ùå ' + (error.message || 'Error al enviar el correo'));
            }
        }

        // OAUTH LOGIN
        async function handleOAuthLogin(provider) {
            hideAuthMessages();

            try {
                // Usar la URL completa actual (sin hash ni query params)
                const currentUrl = window.location.origin + window.location.pathname;

                const { data, error } = await supabaseClient.auth.signInWithOAuth({
                    provider: provider,
                    options: {
                        redirectTo: currentUrl
                    }
                });

                if (error) throw error;

            } catch (error) {
                console.error('Error en OAuth:', error);
                showAuthError('‚ùå ' + (error.message || 'Error al iniciar sesi√≥n con ' + provider));
            }
        }

        // VERIFICAR SESI√ìN AL CARGAR
        async function checkAuthSession() {
            try {
                const { data: { session }, error } = await supabaseClient.auth.getSession();

                if (error) throw error;

                if (session && session.user) {
                    currentUser = session.user;
                    document.getElementById('authOverlay').classList.add('hidden');
                    updateUserInfo(session.user);
                } else {
                    document.getElementById('authOverlay').classList.remove('hidden');
                    hideUserInfo();
                }

                authInitialized = true;

            } catch (error) {
                console.error('Error al verificar sesi√≥n:', error);
                document.getElementById('authOverlay').classList.remove('hidden');
                hideUserInfo();
                authInitialized = true;
            }
        }

        // ACTUALIZAR INFO DE USUARIO EN UI
        function updateUserInfo(user) {
            if (user && user.email) {
                document.getElementById('userEmail').textContent = user.email;
                document.getElementById('userInfo').style.display = 'block';
            }
        }

        // OCULTAR INFO DE USUARIO
        function hideUserInfo() {
            document.getElementById('userInfo').style.display = 'none';
        }

        // =====================================================
        // VARIABLES GLOBALES
        // =====================================================
        
        let scene, camera, renderer;
        let ledGroup;
        let ledMeshes = [];
        let ledColors = {};
        let ledPositions = [];
        
        const totalLeds = 179;
        let paintMode = false;
        let selectedColor = '#ff0000';
        let currentBrightness = 128;
        
        let effectAnimationInterval = null;
        let localAnimationInterval = null;
        let currentEffect = null;
        let currentLocalAnimation = null;
        let currentEffectId = 0; // Efecto actual de WLED (fx)
        let currentPaletteId = 0; // Paleta actual de WLED (pal)

        // Variable para guardar el √∫ltimo estado de WLED
        let pendingWLEDState = null;
        let ledsReady = false;

        // Protecci√≥n contra loops: rastrear √∫ltimo estado procesado
        let lastProcessedState = null;
        let lastProcessedTime = 0;

        // Flag para rastrear si ya aplicamos el brillo inicial desde localStorage
        let initialBrightnessSet = false;

        // CONFIGURACI√ìN MQTT MOSQUITTO
        let mqttClient = null;
        const MQTT_CONFIG = {
            broker: 'wss://mqtt.vittence.com:8084/mqtt',
            topic: 'wled/tree/api',
            username: '',
            password: ''
        };
        let COLOR_ORDER = 'RGB';
        
        // VARIABLES DE PROGRAMACI√ìN
        let schedules = [];
        let schedulerInterval = null;
        let lastScheduleState = null;
        let wledIsOn = false; // Rastrea si WLED est√° encendido o apagado
        let wledStateReceived = false; // Rastrea si hemos recibido al menos un estado de WLED
        let userTimezone = 'America/Santo_Domingo'; // Zona horaria del usuario

        // D√≠as de la semana
        const DAYS = ['Domingo', 'Lunes', 'Martes', 'Mi√©rcoles', 'Jueves', 'Viernes', 'S√°bado'];
        const DAYS_SHORT = ['Dom', 'Lun', 'Mar', 'Mi√©', 'Jue', 'Vie', 'S√°b'];
        // =====================================================
        // FUNCIONES DE SCHEDULE MODAL
        // =====================================================
        
        function openSchedule() {
            const modal = document.getElementById('scheduleModal');
            if (modal) {
                modal.classList.add('active');
                loadSchedules();
                renderScheduleGrid();
                updateSchedulerStatus();
            }
        }

        function closeSchedule() {
            const modal = document.getElementById('scheduleModal');
            if (modal) {
                modal.classList.remove('active');
            }
        }
        
        function closeSchedule() {
            const modal = document.getElementById('scheduleModal');
            modal.classList.add('closing');
    
            setTimeout(() => {
                modal.classList.remove('active');
                modal.classList.remove('closing');
            }, 300);
        }
        
        // =====================================================
        // SISTEMA DE PROGRAMACI√ìN AVANZADO
        // =====================================================
        
        function loadSchedules() {
            try {
                // Intentar cargar horarios normales
                const savedSchedules = localStorage.getItem('wledSchedules');
                if (savedSchedules && savedSchedules !== 'undefined') {
                    schedules = JSON.parse(savedSchedules);
                    addDebugLog(`üìÖ ${schedules.length} horarios cargados desde localStorage`, 'info');
                } else {
                    // Intentar cargar desde respaldo
                    const backup = localStorage.getItem('wledSchedules_backup');
                    if (backup && backup !== 'undefined') {
                        const backupData = JSON.parse(backup);
                        schedules = backupData.schedules || [];
                        addDebugLog(`üìÖ ${schedules.length} horarios recuperados desde respaldo`, 'info');
                        // Restaurar el archivo principal
                        localStorage.setItem('wledSchedules', JSON.stringify(schedules));
                    }
                }

                const enabled = localStorage.getItem('schedulerEnabled') === 'true';
                const checkbox = document.getElementById('schedulerEnabled');
                if (checkbox) {
                    checkbox.checked = enabled;
                }
            } catch (e) {
                console.error('Error al cargar horarios:', e);
                addDebugLog('‚ùå Error al cargar horarios: ' + e.message, 'error');
                schedules = []; // Resetear a array vac√≠o en caso de error
            }
        }
        
        function saveSchedules() {
            try {
                // Guardar en localStorage con respaldo
                const schedulesJson = JSON.stringify(schedules);
                localStorage.setItem('wledSchedules', schedulesJson);

                // Respaldo adicional con timestamp
                const backup = {
                    schedules: schedules,
                    enabled: document.getElementById('schedulerEnabled')?.checked || false,
                    timezone: userTimezone,
                    lastSaved: new Date().toISOString()
                };
                localStorage.setItem('wledSchedules_backup', JSON.stringify(backup));

                renderScheduleGrid();

                // Publicar horarios en MQTT para sincronizar entre dispositivos
                if (mqttClient && mqttClient.connected) {
                    const schedulesData = {
                        schedules: schedules,
                        enabled: document.getElementById('schedulerEnabled').checked,
                        timezone: userTimezone,
                        timestamp: Date.now()
                    };
                    mqttClient.publish('wled/tree/schedules', JSON.stringify(schedulesData), { retain: true });
                    addDebugLog('üì§ Horarios guardados y publicados', 'success');
                }
            } catch (e) {
                console.error('Error al guardar horarios:', e);
                addDebugLog('‚ùå Error al guardar horarios: ' + e.message, 'error');
            }
        }
        
        function addSchedule() {
            const selectedDays = [];
            for (let i = 0; i < 7; i++) {
                if (document.getElementById(`day-${i}`).checked) {
                    selectedDays.push(i);
                }
            }
            
            if (selectedDays.length === 0) {
                showStatus('‚ùå Selecciona al menos un d√≠a', true);
                return;
            }
            
            const startTime = document.getElementById('scheduleStartTime').value;
            const endTime = document.getElementById('scheduleEndTime').value;
            
            if (!startTime || !endTime) {
                showStatus('‚ùå Define las horas de inicio y fin', true);
                return;
            }
            
            const schedule = {
                id: Date.now(),
                days: selectedDays,
                startTime: startTime,
                endTime: endTime,
    
                enabled: true
            };
            schedules.push(schedule);
            saveSchedules();
            
            // Limpiar formulario
            for (let i = 0; i < 7; i++) {
                document.getElementById(`day-${i}`).checked = false;
            }
            document.getElementById('scheduleStartTime').value = '07:00';
            document.getElementById('scheduleEndTime').value = '21:00';
            showStatus('‚úÖ Horario agregado correctamente');
            addDebugLog('üìÖ Nuevo horario agregado', 'success');
        }
        
        function deleteSchedule(id) {
            schedules = schedules.filter(s => s.id !== id);
            saveSchedules();
            showStatus('‚úÖ Horario eliminado');
            addDebugLog('üóëÔ∏è Horario eliminado', 'info');
        }
        
        function toggleSchedule(id) {
            const schedule = schedules.find(s => s.id === id);
            if (schedule) {
                schedule.enabled = !schedule.enabled;
                saveSchedules();
                addDebugLog(`üìÖ Horario ${schedule.enabled ? 'activado' : 'desactivado'}`, 'info');
            }
        }
        
        // INICIO: Soluci√≥n #3 - Modificaci√≥n de renderScheduleGrid para overnight
        function renderScheduleGrid() {
            const grid = document.getElementById('scheduleGrid');
            grid.innerHTML = '';
            
            // Crear columnas para cada d√≠a
            for (let day = 0; day < 7; day++) {
                const dayColumn = document.createElement('div');
                dayColumn.className = 'day-column';
                
                const dayHeader = document.createElement('div');
                dayHeader.className = 'day-header';
                dayHeader.textContent = DAYS_SHORT[day];
                
                const daySchedule = document.createElement('div');
                daySchedule.className = 'day-schedule';
                
                // Agregar bloques de horario para este d√≠a
                schedules.forEach(schedule => {
                    // Los horarios desactivados se muestran en gris (con clase 'inactive')
                    const [startH, startM] = schedule.startTime.split(':').map(Number);
                    const [endH, endM] = schedule.endTime.split(':').map(Number);
                    
                    const startMinutes = startH * 60 + startM;
                    const endMinutes = endH * 60 + endM;

                    const isOvernight = endMinutes < startMinutes;

                    if (!isOvernight) {
                        // --- Horario Normal (mismo d√≠a) ---
                        if (schedule.days.includes(day)) {
                            const block = createScheduleBlock(schedule, startMinutes, endMinutes);
                            daySchedule.appendChild(block);
                        }
                    } else {
                        // --- Horario Overnight (pasa la medianoche) ---
                        
                        // 1. Parte que *empieza* hoy y termina ma√±ana
                        if (schedule.days.includes(day)) {
                            const block = createScheduleBlock(schedule, startMinutes, 1440); // 1440 = 24:00
                            daySchedule.appendChild(block);
                        }

                        // 2. Parte que *termina* hoy (empez√≥ ayer)
                        const prevDay = (day === 0) ? 6 : day - 1; // 6 = S√°bado
                        if (schedule.days.includes(prevDay)) {
                            const block = createScheduleBlock(schedule, 0, endMinutes); // 0 = 00:00
                            daySchedule.appendChild(block);
                        }
                    }
                });

                dayColumn.appendChild(dayHeader);
                dayColumn.appendChild(daySchedule);
                grid.appendChild(dayColumn);
            }
        }
        // FIN: Soluci√≥n #3

        // INICIO: Soluci√≥n #2 y #3 - Modificaci√≥n de createScheduleBlock
        // (Ahora acepta startMinutes y endMinutes para manejar bloques divididos)
        function createScheduleBlock(schedule, startMinutes, endMinutes) {
            
            const block = document.createElement('div');
            block.className = `schedule-block ${schedule.enabled ? '' : 'inactive'}`;
            
            // Calcular posici√≥n y altura
            const top = startMinutes; // 1 pixel por minuto
            const height = endMinutes - startMinutes;
            
            block.style.top = `${top}px`;
            block.style.height = `${height}px`;
            
            // Soluci√≥n #2: Solo mostrar texto si el bloque es lo suficientemente alto
            if (height >= 40) { // 40 minutos o m√°s
                block.innerHTML = `
                    <strong>${schedule.startTime}</strong>
                    <span>a</span>
                    <strong>${schedule.endTime}</strong>
                `;
            } else {
                // Si es muy peque√±o, al menos poner un tooltip
                block.title = `${schedule.startTime} - ${schedule.endTime}`;
            }
            
            // L√≥gica: 1 click = Activar/Desactivar. 2 clicks = Eliminar.
            // Usamos un sistema de detecci√≥n de doble click para evitar conflictos
            let clickTimer = null;
            let clickCount = 0;

            block.addEventListener('click', (e) => {
                e.preventDefault();
                clickCount++;

                if (clickCount === 1) {
                    // Primer click: esperar para ver si hay un segundo click
                    clickTimer = setTimeout(() => {
                        // Solo hubo un click ‚Üí toggle activar/desactivar
                        toggleSchedule(schedule.id);
                        clickCount = 0;
                    }, 250); // 250ms de espera para detectar doble click
                } else if (clickCount === 2) {
                    // Segundo click ‚Üí eliminar
                    clearTimeout(clickTimer);
                    clickCount = 0;

                    if (confirm('¬øEst√°s seguro de que deseas ELIMINAR este horario permanentemente?')) {
                        deleteSchedule(schedule.id);
                    }
                }
            });

            return block;
        }
        // FIN: Soluci√≥n #2 y #3
        
        // Funciones de horarios r√°pidos
        function setWeekdaySchedule() {
            const schedule = {
                id: Date.now(),
                days: [1, 2, 3, 4, 5],
                startTime: '07:00',
                endTime: '21:00',
                enabled: true
            };
            schedules.push(schedule);
            saveSchedules();
            showStatus('‚úÖ Horario Lun-Vie agregado');
        }
        
        function setWeekendSchedule() {
            const schedule = {
                id: Date.now(),
                days: [0, 6],
                startTime: '09:00',
                 endTime: '23:00',
                enabled: true
            };
            schedules.push(schedule);
            saveSchedules();
            showStatus('‚úÖ Horario Fin de Semana agregado');
        }
        
        function setEveningSchedule() {
            const schedule = {
                id: Date.now(),
                days: [0, 1, 2, 3, 4, 5, 6],
                startTime: '17:00',
                endTime: '23:00',
                enabled: true
            };
            schedules.push(schedule);
            saveSchedules();
            showStatus('‚úÖ Horario de Tardes agregado');
        }
        
        function clearAllSchedules() {
            if (confirm('¬øEliminar TODOS los horarios programados?')) {
                schedules = [];
                saveSchedules();
                showStatus('‚úÖ Todos los horarios eliminados');
            }
        }
        
        function updateScheduler() {
            const enabled = document.getElementById('schedulerEnabled').checked;
            localStorage.setItem('schedulerEnabled', enabled.toString());

            updateSchedulerStatus();

            if (enabled) {
                showStatus('‚úÖ Programaci√≥n autom√°tica activada');
                addDebugLog('‚è∞ Programaci√≥n autom√°tica activada', 'success');
                checkSchedules();
            } else {
                showStatus('‚è∏Ô∏è Programaci√≥n autom√°tica desactivada');
                addDebugLog('‚è∞ Programaci√≥n autom√°tica desactivada', 'info');
            }

            // Publicar cambio en MQTT para sincronizar entre dispositivos
            if (mqttClient && mqttClient.connected) {
                const schedulesData = {
                    schedules: schedules,
                    enabled: enabled,
                    timestamp: Date.now()
                };
                mqttClient.publish('wled/tree/schedules', JSON.stringify(schedulesData), { retain: true });
                addDebugLog('üì§ Estado del scheduler publicado', 'success');
            }
        }

        function saveTimezone() {
            const select = document.getElementById('timezoneSelect');
            if (select) {
                userTimezone = select.value;
                localStorage.setItem('userTimezone', userTimezone);
                addDebugLog(`üåç Zona horaria cambiada a: ${userTimezone}`, 'info');

                // Reiniciar el estado del scheduler para forzar nueva verificaci√≥n
                lastScheduleState = null;

                // Verificar horarios con nueva timezone
                if (document.getElementById('schedulerEnabled')?.checked) {
                    setTimeout(() => checkSchedules(), 100);
                }
            }
        }

        function loadTimezone() {
            const saved = localStorage.getItem('userTimezone');
            if (saved && saved !== 'undefined' && saved !== 'null') {
                userTimezone = saved;
                const select = document.getElementById('timezoneSelect');
                if (select) {
                    select.value = userTimezone;
                    addDebugLog(`üåç Zona horaria cargada: ${userTimezone}`, 'info');
                }
            } else {
                // Asegurar que siempre haya un valor v√°lido
                userTimezone = 'America/Santo_Domingo';
                localStorage.setItem('userTimezone', userTimezone);
                addDebugLog(`üåç Zona horaria establecida por defecto: ${userTimezone}`, 'info');
                const select = document.getElementById('timezoneSelect');
                if (select) {
                    select.value = userTimezone;
                }
            }
        }

        function updateSchedulerStatus() {
            // Verificar que el elemento exista antes de usarlo
            const schedulerCheckbox = document.getElementById('schedulerEnabled');
            const statusText = document.getElementById('scheduleStatusText');
    
            if (!schedulerCheckbox || !statusText) {
                return;
            }
    
            const enabled = schedulerCheckbox.checked;
            if (enabled) {
                const activeSchedule = getActiveSchedule();
                if (activeSchedule) {
                    statusText.textContent = `‚úÖ ENCENDIDO (hasta ${activeSchedule.endTime})`;
                    statusText.style.color = '#28a745';
                } else {
                    statusText.textContent = `‚è∏Ô∏è APAGADO (esperando horario)`;
                    statusText.style.color = '#dc3545';
                }
            } else {
                statusText.textContent = 'Desactivado';
                statusText.style.color = '#6c757d';
            }
        }
        
        function getActiveSchedule() {
            // Validar que userTimezone est√© definida
            if (!userTimezone || userTimezone === 'undefined') {
                userTimezone = 'America/Santo_Domingo';
            }

            // Obtener fecha/hora en la zona horaria configurada por el usuario
            let formatter, parts;
            try {
                formatter = new Intl.DateTimeFormat('en-US', {
                    timeZone: userTimezone,
                    hour: '2-digit',
                    minute: '2-digit',
                    hour12: false,
                    weekday: 'short'
                });
                parts = formatter.formatToParts(new Date());
            } catch (e) {
                console.error('Error con zona horaria:', e);
                // Fallback a zona horaria por defecto
                userTimezone = 'America/Santo_Domingo';
                formatter = new Intl.DateTimeFormat('en-US', {
                    timeZone: userTimezone,
                    hour: '2-digit',
                    minute: '2-digit',
                    hour12: false,
                    weekday: 'short'
                });
                parts = formatter.formatToParts(new Date());
            }

            const hours = parseInt(parts.find(p => p.type === 'hour').value);
            const minutes = parseInt(parts.find(p => p.type === 'minute').value);
            const weekday = parts.find(p => p.type === 'weekday').value;

            // Mapear d√≠a de la semana
            const dayMap = { 'Sun': 0, 'Mon': 1, 'Tue': 2, 'Wed': 3, 'Thu': 4, 'Fri': 5, 'Sat': 6 };
            const currentDay = dayMap[weekday];
            const currentTime = hours * 60 + minutes;

            for (const schedule of schedules) {
                if (!schedule.enabled) continue;
                
                const [startH, startM] = schedule.startTime.split(':').map(Number);
                const [endH, endM] = schedule.endTime.split(':').map(Number);
                const startMinutes = startH * 60 + startM;
                const endMinutes = endH * 60 + endM;

                const isOvernight = endMinutes < startMinutes;

                if (!isOvernight) {
                    // --- Horario Normal ---
                    // Encendido desde startTime (inclusive) hasta endTime (exclusive)
                    // Ejemplo: 18:00-23:00 significa encendido de 18:00 a 22:59, apaga a las 23:00
                    if (schedule.days.includes(currentDay) && currentTime >= startMinutes && currentTime < endMinutes) {
                        return schedule;
                    }
                } else {
                    // --- Horario Overnight ---
                    const prevDay = (currentDay === 0) ? 6 : currentDay - 1;

                    // 1. ¬øEst√° activo *despu√©s* de medianoche? (p.ej. 02:00)
                    // Desde 00:00 (inclusive) hasta endTime (exclusive)
                    if (schedule.days.includes(prevDay) && currentTime >= 0 && currentTime < endMinutes) {
                        return schedule;
                    }
                    // 2. ¬øEst√° activo *antes* de medianoche? (p.ej. 22:00)
                    // Desde startTime (inclusive) hasta 23:59 (inclusive)
                    if (schedule.days.includes(currentDay) && currentTime >= startMinutes && currentTime <= 1439) {
                        return schedule;
                    }
                }
            }
            
            return null;
        }
        
        async function checkSchedules() {
            // VALIDAR PRIMERO SI HAY CONEXI√ìN
            if (!mqttClient || !mqttClient.connected) {
                // No mostrar error constantemente, solo la primera vez
                if (schedulerInterval && !window.schedulerConnectionWarned) {
                    addDebugLog('‚ö†Ô∏è Esperando conexi√≥n MQTT para scheduler...', 'info');
                    window.schedulerConnectionWarned = true;
                }
                return;
            }

            // Resetear warning cuando se reconecta
            if (window.schedulerConnectionWarned) {
                addDebugLog('‚úÖ Conexi√≥n MQTT restaurada - Scheduler activo', 'success');
                window.schedulerConnectionWarned = false;
            }

            // VALIDAR SI EL SCHEDULER EST√Å HABILITADO
            if (!document.getElementById('schedulerEnabled') || !document.getElementById('schedulerEnabled').checked) {
                return;
            }

            const activeSchedule = getActiveSchedule();
            const shouldBeOn = activeSchedule !== null;

            // Al inicio, sincronizar lastScheduleState
            const isFirstRun = lastScheduleState === null;
            if (isFirstRun) {
                lastScheduleState = shouldBeOn;
                addDebugLog(`üîÑ Estado inicial del scheduler: ${shouldBeOn ? 'Horario activo' : 'Fuera de horario'}`, 'info');
                // Si no hemos recibido estado de WLED, asumir apagado (wledIsOn = false)
                if (!wledStateReceived) {
                    addDebugLog('‚ÑπÔ∏è Estado de WLED no recibido a√∫n, asumiendo apagado inicialmente', 'info');
                    wledIsOn = false;
                }
            }

            // Detectar cambios de horario (transici√≥n de encendido/apagado)
            const scheduleStateChanged = !isFirstRun && (lastScheduleState !== shouldBeOn);

            // Detectar desincronizaci√≥n: el estado real no coincide con el horario
            // SOLO verificar desincronizaci√≥n despu√©s de la primera ejecuci√≥n
            const isOutOfSync = !isFirstRun && (wledIsOn !== shouldBeOn);

            // Log para debug SOLO cuando hay cambios o desincronizaci√≥n
            if (scheduleStateChanged || isOutOfSync) {
                addDebugLog(`üîç Verificaci√≥n: shouldBeOn=${shouldBeOn}, wledIsOn=${wledIsOn}, isOutOfSync=${isOutOfSync}`, 'info');
            }

            if (scheduleStateChanged) {
                // El horario cambi√≥ (ej: pas√≥ de 22:59 a 23:00)
                lastScheduleState = shouldBeOn;
                addDebugLog(`‚è∞ Cambio de horario detectado: ${shouldBeOn ? 'Entrando en horario' : 'Saliendo de horario'}`, 'info');
            }

            // Forzar el estado correcto si hay cambio o desincronizaci√≥n
            if (scheduleStateChanged || isOutOfSync) {
                if (shouldBeOn && !wledIsOn) {
                    // Debe estar encendido pero est√° apagado
                    addDebugLog('‚è∞ Horario activo - Encendiendo LEDs', 'success');
                    showStatus('‚è∞ Horario: Encendiendo LEDs');

                    await sendMQTTCommand({
                        "on": true,
                        "bri": currentBrightness
                    });
                    wledIsOn = true;
                } else if (!shouldBeOn && wledIsOn) {
                    // Debe estar apagado pero est√° encendido (forzar apagado)
                    addDebugLog('‚è∞ Fuera de horario - Apagando LEDs (forzado)', 'info');
                    showStatus('‚è∞ Fuera de horario: Apagando LEDs');

                    await sendMQTTCommand({
                        "on": false
                    });
                    updateAllLEDsVisual('#000000');
                    wledIsOn = false;
                }
            }

            updateSchedulerStatus();
        }

        async function testScheduleOff() {
            addDebugLog('üß™ Test: Enviando comando OFF completo', 'info');
            const offCommand = {
                "on": false,
                "bri": 0,
                "seg": [{
                    "id": 0,
                    "on": false,
                    "bri": 0,
                    "fx": 0,
                    "col": [[0,0,0], [0,0,0], [0,0,0]]
                }],
                "transition": 0
             };
    
            const success = await sendMQTTCommand(offCommand);
            if (success) {
                updateAllLEDsVisual('#000000');
                showStatus('‚úÖ Comando OFF de prueba enviado');
            }
        }
        
        // =====================================================
        // DEBUG LOG
        // =====================================================
        
        function addDebugLog(message, type = 'info') {
            const logDiv = document.getElementById('debugLog');
            const entry = document.createElement('div');
            entry.className = type;
            const timestamp = new Date().toLocaleTimeString();
            entry.textContent = `[${timestamp}] ${message}`;
            logDiv.appendChild(entry);
            logDiv.scrollTop = logDiv.scrollHeight;
            while (logDiv.children.length > 50) {
                logDiv.removeChild(logDiv.firstChild);
            }
        }
        
        // =====================================================
        // CONEXI√ìN MQTT (mantener las funciones existentes)
        // =====================================================
        
        function initMQTT() {
            addDebugLog('üîå Iniciando conexi√≥n a Mosquitto...', 'info');
            addDebugLog(`üì° Broker: ${MQTT_CONFIG.broker}`, 'info');
            
            const options = {
                clientId: 'web-tree-' + Math.random().toString(16).substr(2, 8),
                clean: true,
                reconnectPeriod: 5000,
                connectTimeout: 30000,
                protocol: 'wss',
                 protocolVersion: 4,
                rejectUnauthorized: true,
                keepalive: 60
            };
            if (MQTT_CONFIG.username) {
                options.username = MQTT_CONFIG.username;
                options.password = MQTT_CONFIG.password;
            }
            
            try {
                mqttClient = mqtt.connect(MQTT_CONFIG.broker, options);
                mqttClient.on('connect', () => {
                    addDebugLog('‚úÖ Conectado exitosamente a Mosquitto!', 'success');
                    document.getElementById('connectionStatus').className = 'connection-status connected';
                    document.getElementById('connectionStatus').textContent = '‚úÖ Conectado';
                    
                     mqttClient.subscribe('wled/tree/#', (err) => {
                        if (!err) {
                            addDebugLog('üì° Suscrito a topics WLED', 'success');
                            addDebugLog('‚è≥ Esperando estado de WLED desde wled/tree/v...', 'info');

                            // WLED publica autom√°ticamente su estado al topic wled/tree/v en formato XML
                            // No es necesario solicitar el estado manualmente
                            // El estado llegar√° en los pr√≥ximos segundos si MQTT est√° habilitado en WLED

                            // Publicar horarios locales despu√©s de suscribirse
                            // Si hay horarios retenidos en MQTT, llegar√°n primero y sobrescribir√°n estos
                            setTimeout(() => {
                                if (schedules.length > 0 || document.getElementById('schedulerEnabled').checked) {
                                    const schedulesData = {
                                        schedules: schedules,
                                        enabled: document.getElementById('schedulerEnabled').checked,
                                        timestamp: Date.now()
                                    };
                                    mqttClient.publish('wled/tree/schedules', JSON.stringify(schedulesData), { retain: true });
                                    addDebugLog('üì§ Horarios locales publicados al conectar', 'info');
                                }
                            }, 500);
                        } else {
                            addDebugLog('‚ö†Ô∏è Error al suscribirse: ' + err.message, 'error');
                        }
                    });
                });
                mqttClient.on('error', (err) => {
                    addDebugLog('‚ùå Error MQTT: ' + err.message, 'error');
                    document.getElementById('connectionStatus').className = 'connection-status disconnected';
                    document.getElementById('connectionStatus').textContent = '‚ùå Error de conexi√≥n';
                });
                mqttClient.on('reconnect', () => {
                    addDebugLog('üîÑ Intentando reconectar...', 'info');
                    document.getElementById('connectionStatus').className = 'connection-status connecting';
                    document.getElementById('connectionStatus').textContent = 'üîÑ Reconectando...';

                    // Al reconectar, resetear el estado del scheduler para forzar nueva verificaci√≥n
                    lastScheduleState = null;
                    wledStateReceived = false;
                });
                mqttClient.on('offline', () => {
                    addDebugLog('‚ö†Ô∏è Cliente MQTT offline', 'error');
                    document.getElementById('connectionStatus').className = 'connection-status disconnected';
                    document.getElementById('connectionStatus').textContent = '‚ö†Ô∏è Desconectado';
                });

                // INICIO: Soluci√≥n #5 - Procesar mensajes de estado de WLED
                mqttClient.on('message', (topic, message) => {
                    const payloadStr = message.toString();

                    // Procesar mensajes de brillo para sincronizaci√≥n entre dispositivos
                    if (topic === 'wled/tree/brightness') {
                        const brightness = parseInt(payloadStr);
                        if (!isNaN(brightness) && brightness >= 0 && brightness <= 255) {
                            // Solo actualizar si es diferente del actual (evitar loops)
                            if (Math.abs(brightness - currentBrightness) > 2) {
                                currentBrightness = brightness;
                                document.getElementById('brightness').value = brightness;
                                updateBrightnessLabel(brightness);
                                localStorage.setItem('lastBrightness', brightness.toString());
                                addDebugLog(`üí° Brillo sincronizado desde otro dispositivo: ${brightness}`, 'success');
                            }
                        }
                        return;
                    }

                    // Procesar mensajes de horarios para sincronizaci√≥n entre dispositivos
                    if (topic === 'wled/tree/schedules') {
                        try {
                            const data = JSON.parse(payloadStr);
                            if (data.schedules && Array.isArray(data.schedules)) {
                                // Evitar loop si es nuestro propio mensaje (comparar timestamp reciente)
                                const timeDiff = Date.now() - (data.timestamp || 0);
                                if (timeDiff > 1000) { // Solo aplicar si tiene m√°s de 1 segundo
                                    schedules = data.schedules;
                                    localStorage.setItem('wledSchedules', JSON.stringify(schedules));

                                    if (typeof data.enabled !== 'undefined') {
                                        document.getElementById('schedulerEnabled').checked = data.enabled;
                                        localStorage.setItem('schedulerEnabled', data.enabled.toString());
                                    }

                                    renderScheduleGrid();
                                    addDebugLog('üì• Horarios sincronizados desde otro dispositivo', 'success');
                                }
                            }
                        } catch (e) {
                            addDebugLog('‚ùå Error al procesar horarios: ' + e.message, 'error');
                        }
                        return;
                    }

                    // Procesar mensajes de estado de WLED (v, state, o api con JSON de estado)
                    if (topic === 'wled/tree/v' || topic === 'wled/tree/state' || topic === 'wled/tree/api') {
                        const trimmedPayload = payloadStr.trim();

                        // Mostrar preview del contenido (incluso si est√° vac√≠o)
                        if (trimmedPayload.length === 0) {
                            addDebugLog(`üì® ${topic}: (vac√≠o)`, 'info');
                            return;
                        }

                        const preview = trimmedPayload.substring(0, 80);
                        addDebugLog(`üì® ${topic}: ${preview}${trimmedPayload.length > 80 ? '...' : ''}`, 'success');

                        // Detectar si es XML
                        if (trimmedPayload.startsWith('<?xml') || trimmedPayload.startsWith('<')) {
                            const state = parseWLEDXML(trimmedPayload);
                            if (state) {
                                handleWLEDState(state);
                            }
                            return;
                        }

                        // Validar que el payload sea JSON v√°lido antes de parsear
                        if (!trimmedPayload.startsWith('{') && !trimmedPayload.startsWith('[')) {
                            addDebugLog(`‚ö†Ô∏è ${topic}: Formato desconocido`, 'error');
                            return;
                        }

                        try {
                            const data = JSON.parse(payloadStr);

                            // Solo procesar si es un estado COMPLETO (no comandos parciales)
                            // Un estado completo debe tener al menos 'state' o tanto 'on' como 'seg'
                            const isCompleteState = data.state || (data.seg && data.on !== undefined);

                            if (isCompleteState) {
                                addDebugLog(`üìä Estado completo detectado en ${topic}`, 'info');
                                const state = data.state || data;
                                handleWLEDState(state);
                            } else {
                                addDebugLog(`‚è© Comando parcial ignorado en ${topic} (solo tiene: ${Object.keys(data).join(',')})`, 'info');
                            }
                        } catch (e) {
                            // Ignorar errores de JSON parse silenciosamente
                        }
                    }
                    // Ignorar silenciosamente otros topics (g, c, status, etc.)
                });
                // FIN: Soluci√≥n #5

            } catch (error) {
                addDebugLog('‚ùå Error cr√≠tico al inicializar: ' + error.message, 'error');
            }
        }
        
        function reconnectMQTT() {
            if (mqttClient) {
                addDebugLog('üîÑ Desconectando cliente anterior...', 'info');
                mqttClient.end(true);
                mqttClient = null;
            }
            setTimeout(() => {
                initMQTT();
            }, 500);
        }

        // Funci√≥n para parsear XML de WLED y convertirlo a formato JSON (actualizado)
        function parseWLEDXML(xmlString) {
            try {
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(xmlString, "text/xml");

                // Verificar si hay errores de parseo
                const parseError = xmlDoc.querySelector('parsererror');
                if (parseError) {
                    throw new Error('Error al parsear XML');
                }

                const vs = xmlDoc.querySelector('vs');
                if (!vs) {
                    throw new Error('No se encontr√≥ elemento <vs> en XML');
                }

                // Extraer brillo (ac = actual brightness)
                const acElement = vs.querySelector('ac');
                const brightness = acElement ? parseInt(acElement.textContent) : 128;

                // Extraer colores primarios (cl = color)
                const clElements = vs.querySelectorAll('cl');
                const colors = Array.from(clElements).map(el => parseInt(el.textContent));

                // Extraer efecto (fx)
                const fxElement = vs.querySelector('fx');
                const fx = fxElement ? parseInt(fxElement.textContent) : 0;

                // Extraer paleta (fp)
                const fpElement = vs.querySelector('fp');
                const pal = fpElement ? parseInt(fpElement.textContent) : 0;

                // Determinar si est√° encendido (si hay brillo o si el XML lo indica)
                const isOn = brightness > 0;

                // Crear objeto compatible con handleWLEDState
                const state = {
                    on: isOn,
                    bri: brightness,
                    seg: [{
                        col: [colors.length >= 3 ? colors.slice(0, 3) : [255, 255, 255]],
                        fx: fx,
                        pal: pal
                    }]
                };

                addDebugLog(`‚úÖ Estado: ${isOn ? 'ON' : 'OFF'}, Brillo: ${brightness}, FX: ${fx}, Pal: ${pal}`, 'success');

                return state;
            } catch (e) {
                addDebugLog('‚ùå Error al parsear XML de WLED: ' + e.message, 'error');
                return null;
            }
        }

        // INICIO: Soluci√≥n #5 - Nueva funci√≥n para manejar el estado de WLED
        function handleWLEDState(state) {
            if (!state) {
                addDebugLog('‚ö†Ô∏è Estado WLED recibido pero vac√≠o', 'error');
                return;
            }

            // Si los LEDs no est√°n listos, guardar el estado para aplicarlo despu√©s
            if (!ledsReady || ledMeshes.length === 0) {
                addDebugLog('‚è≥ LEDs no listos, guardando estado para aplicar despu√©s...', 'info');
                pendingWLEDState = state;
                return;
            }

            // Protecci√≥n contra loops: evitar procesar el mismo estado m√∫ltiples veces
            const now = Date.now();
            const fx = state.seg?.[0]?.fx;
            const pal = state.seg?.[0]?.pal;
            const bri = state.bri;
            const stateSignature = `${fx}-${pal}-${bri}`;

            // Si es el mismo estado que acabamos de procesar hace menos de 800ms, ignorarlo
            if (stateSignature === lastProcessedState && (now - lastProcessedTime) < 800) {
                return; // Ignorar para evitar loop
            }

            lastProcessedState = stateSignature;
            lastProcessedTime = now;

            // 1. Actualizar Brillo
            if (typeof state.bri !== 'undefined') {
                const brightness = state.bri;

                // PRIMERA VEZ: Priorizar brillo guardado en localStorage
                if (!initialBrightnessSet) {
                    const savedBrightness = localStorage.getItem('lastBrightness');
                    if (savedBrightness) {
                        const localBri = parseInt(savedBrightness);
                        // Si el brillo guardado es diferente al de WLED (m√°s de 2 puntos de diferencia)
                        if (Math.abs(localBri - brightness) > 2) {
                            addDebugLog(`üí° Restaurando brillo guardado: ${localBri} (WLED tiene: ${brightness})`, 'info');
                            currentBrightness = localBri;
                            document.getElementById('brightness').value = localBri;
                            updateBrightnessLabel(localBri);

                            // Enviar el brillo guardado a WLED despu√©s de un segundo
                            setTimeout(() => {
                                sendMQTTCommand({"bri": localBri});
                                if (mqttClient && mqttClient.connected) {
                                    mqttClient.publish('wled/tree/brightness', localBri.toString(), { retain: true });
                                }
                            }, 1000);

                            initialBrightnessSet = true;
                            return;
                        }
                    }
                    initialBrightnessSet = true;
                }

                // SINCRONIZACI√ìN NORMAL: Solo actualizar si hay diferencia significativa
                if (Math.abs(brightness - currentBrightness) > 2) {
                    document.getElementById('brightness').value = brightness;
                    updateBrightnessLabel(brightness);
                    currentBrightness = brightness;

                    // Guardar el brillo en localStorage para persistencia
                    localStorage.setItem('lastBrightness', brightness.toString());

                    // Publicar brillo en MQTT para sincronizar entre dispositivos
                    if (mqttClient && mqttClient.connected) {
                        mqttClient.publish('wled/tree/brightness', brightness.toString(), { retain: true });
                    }
                }
            }

            // 2. Actualizar Estado (On/Off)
            const previousState = wledIsOn;
            wledIsOn = state.on === true; // Actualizar estado global
            wledStateReceived = true; // Marcamos que hemos recibido al menos un estado

            // Log cuando cambia el estado
            if (previousState !== wledIsOn) {
                addDebugLog(`üí° Estado WLED actualizado: ${wledIsOn ? 'Encendido' : 'Apagado'}`, 'info');
            }

            if (typeof state.on === 'undefined' || !state.on) {
                addDebugLog('‚ö´ Apagado', 'info');
                updateAllLEDsVisual('#000000');
                return; // Si est√° apagado, no procesar colores
            }

            // 3. Actualizar Colores y Efectos (basado en el primer segmento)
            if (state.seg && state.seg[0]) {
                const segment = state.seg[0];
                const fx = segment.fx;
                const pal = segment.pal;
                const col = segment.col[0] || [255, 0, 0]; // Color primario, con fallback

                // Sincronizar efecto y paleta actuales
                currentEffectId = fx;
                currentPaletteId = pal || 0;

                const hexColor = rgbToHex(col[0], col[1], col[2]);

                // Actualizar el picker de color de la UI
                selectedColor = hexColor;
                document.getElementById('ledColor').value = hexColor;

                // Detener cualquier animaci√≥n local
                stopAllAnimations();

                if (fx === 0) {
                    // --- Efecto S√≥lido ---
                    addDebugLog(`üîÑ Sincronizando: Color S√≥lido ${hexColor}`, 'info');
                    updateAllLEDsVisual(hexColor);
                } else {
                    // --- Efecto Animado ---
                    addDebugLog(`üîÑ Sincronizando: Efecto ${fx}, Paleta ${pal || 'default'}`, 'info');
                    // Mostrar solo el color base - WLED maneja la animaci√≥n real
                    updateAllLEDsVisual(hexColor);
                }
            }
        }
        // FIN: Soluci√≥n #5
        
        // =====================================================
        // ENV√çO DE COMANDOS MQTT
        // =====================================================
        
        async function sendMQTTCommand(payload) {
            if (!mqttClient || !mqttClient.connected) {
                addDebugLog('‚ùå No hay conexi√≥n MQTT', 'error');
                showStatus('‚ùå No conectado a MQTT', true);
                return false;
            }
            
            const payloadStr = JSON.stringify(payload);
            addDebugLog(`üì§ Enviando comando: ${payloadStr.substring(0, 80)}...`, 'info');
            
            try {
                mqttClient.publish(MQTT_CONFIG.topic, payloadStr, { qos: 1, retain: false }, (err) => {
                    if (err) {
                        addDebugLog('‚ùå Error al publicar: ' + err.message, 'error');
                     } else {
                        addDebugLog('‚úÖ Comando enviado correctamente', 'success');
                    }
                });
                return true;
            } catch (error) {
                addDebugLog('‚ùå Excepci√≥n al publicar: ' + error.message, 'error');
                return false;
            }
        }
        
        async function sendTestMessage() {
            const testPayload = {
                "test": true,
                "timestamp": new Date().toISOString(),
                "message": "Test desde interfaz web"
             };
            
            addDebugLog('üß™ Enviando mensaje de prueba...', 'info');
            const success = await sendMQTTCommand(testPayload);
            
            if (success) {
                showStatus('‚úÖ Mensaje de prueba enviado');
            }
        }
        
        // =====================================================
        // FUNCIONES DE CONTROL (mantener todas las existentes)
        // =====================================================
        
        async function resetWLED() {
            stopAllAnimations();
            addDebugLog('üî¥ Apagando LEDs...', 'info');
            
            await sendMQTTCommand({
                "on": false,
                "seg": [{
                    "fx": 0,
                    "sx": 0,
                    "ix": 0,
                    "pal": 0,
                    "col": [[0,0,0]]
                }]
            });
            updateAllLEDsVisual('#000000');
            showStatus('‚úì LEDs apagados');
        }
        
        function applyColorOrder(r, g, b) {
            switch(COLOR_ORDER) {
                case 'RGB':
                    return [r, g, b];
                case 'GRB':
                    return [g, r, b];
                case 'BGR':
                    return [b, g, r];
                case 'RBG':
                    return [r, b, g];
                case 'GBR':
                    return [g, b, r];
                case 'BRG':
                    return [b, r, g];
                default:
                    return [r, g, b];
            }
        }
        
        // INICIO: Funciones de Diagn√≥stico Eliminadas
        // testColorDirect, cycleColorTest, y testIndividualLEDs han sido eliminadas.
        // FIN: Funciones de Diagn√≥stico Eliminadas
        
        // CONTROL DE LEDS
        function activatePaintMode() {
            paintMode = !paintMode;
            const btn = document.getElementById('paintBtn');
            const palette = document.getElementById('colorPalette');
            
            if (paintMode) {
                btn.classList.add('active');
                btn.textContent = 'Paint Mode: ON';
                palette.style.display = 'grid';
                showStatus('üé® Paint Mode activado');
                addDebugLog('üé® Paint Mode activado', 'info');
            } else {
                btn.classList.remove('active');
                btn.textContent = 'Activar Paint Mode';
                palette.style.display = 'none';
                showStatus('Paint Mode desactivado');
                addDebugLog('Paint Mode desactivado', 'info');
            }
        }
        
        function updateSelectedColor() {
            selectedColor = document.getElementById('ledColor').value;
            addDebugLog(`üé® Color seleccionado: ${selectedColor}`, 'info');
        }
        
        function selectPaletteColor(color) {
            selectedColor = color;
            document.getElementById('ledColor').value = color;
            
            document.querySelectorAll('.palette-color').forEach(el => {
                el.classList.remove('selected');
            });
            event.target.classList.add('selected');
        }
        
        async function updateLEDColor(index, color) {
            if (index < 0 || index >= totalLeds) return;
            ledColors[index] = color;
            updateLEDVisual(index, color, true);
            
            const rgb = hexToRgb(color);
            if (!rgb) return;
            
            const orderedRgb = applyColorOrder(rgb.r, rgb.g, rgb.b);
            await sendMQTTCommand({
                "on": true,
                "seg": [{
                    "fx": 0,
                    "i": [index, orderedRgb]
                }]
             });
        }
        
        function updateLEDVisual(index, color, needsUpdate = true) {
            if (index < 0 || index >= totalLeds || !ledMeshes[index]) return;
            const mesh = ledMeshes[index];
            mesh.material.color.set(color);
            
            if (needsUpdate) {
                mesh.material.needsUpdate = true;
            }
        }
        
        function updateAllLEDsVisual(color) {
            for (let i = 0; i < totalLeds; i++) {
                ledColors[i] = color;
                updateLEDVisual(i, color, false);
            }
            
            ledMeshes.forEach(mesh => {
                mesh.material.needsUpdate = true;
            });
        }
        
        // DISE√ëOS EST√ÅTICOS (mantener todas las funciones existentes)
        function setStaticDesign(designName) {
            stopAllAnimations();
            currentEffect = designName;
            
            addDebugLog(`üé® Aplicando dise√±o est√°tico: ${designName}`, 'info');
            
            document.querySelectorAll('.effect-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            if (event && event.target) {
                event.target.classList.add('active');
            }
            
            switch(designName) {
                case 'OFF':
                    applyOFFDesign();
                    break;
                case 'Solid':
                    applySolidDesign();
                    break;
                case 'Rainbow':
                    applyRainbowDesign();
                    break;
                case 'Warm':
                    applyWarmDesign();
                    break;
                case 'Cold':
                    applyColdDesign();
                    break;
                case 'Purple Rain':
                    applyPurpleRainDesign();
                    break;
                case 'Dominican':
                    applyDominicanDesign();
                    break;
            }
        }

        async function applyOFFDesign() {
            updateAllLEDsVisual('#000000');
            await sendMQTTCommand({ "on": false });
            showStatus('‚úì LEDs apagados');
        }

        async function applySolidDesign() {
            updateAllLEDsVisual(selectedColor);
            const rgb = hexToRgb(selectedColor);
            
            await sendMQTTCommand({
                "on": true,
                "bri": currentBrightness,
                "seg": [{
                    "id": 0,
                    "fx": 0,
                    "col": [applyColorOrder(rgb.r, rgb.g, rgb.b)]
                }]
            });
            showStatus(`‚úì Solid ${selectedColor}`);
        }

        async function applyRainbowDesign(sendToWLED = true) {
            addDebugLog('üåà Aplicando Rainbow', 'info');
            for (let i = 0; i < totalLeds; i++) {
                const hue = (i * 360 / totalLeds) % 360;
                const color = hslToRgb(hue, 100, 50);
                const hexColor = rgbToHex(color.r, color.g, color.b);
                updateLEDVisual(i, hexColor, false);
            }
            ledMeshes.forEach(mesh => mesh.material.needsUpdate = true);

            if (sendToWLED) {
                await sendMQTTCommand({
                    "on": true,
                    "bri": currentBrightness,
                    "seg": [{
                        "id": 0,
                        "fx": 9,
                        "pal": 11
                    }]
                });
            }
            showStatus('‚úì Rainbow aplicado');
        }

        async function applyWarmDesign() {
            const warmColor = '#ffe4b5';
            updateAllLEDsVisual(warmColor);
            
            const rgb = hexToRgb(warmColor);
            
            await sendMQTTCommand({
                "on": true,
                "bri": currentBrightness,
                "seg": [{
                    "id": 0,
                    "fx": 0,
                     "col": [applyColorOrder(rgb.r, rgb.g, rgb.b)]
                }]
            });
            showStatus('‚úì Warm aplicado');
        }

        async function applyColdDesign() {
            addDebugLog('‚ùÑÔ∏è Aplicando Cold', 'info');
            const coldColors = ['#0066ff', '#00ccff', '#6600ff', '#00ffff', '#3366ff'];
            for (let i = 0; i < totalLeds; i++) {
                const colorHex = coldColors[i % coldColors.length];
                updateLEDVisual(i, colorHex, false);
            }
            ledMeshes.forEach(mesh => mesh.material.needsUpdate = true);
            await sendMQTTCommand({
                "on": true,
                "bri": currentBrightness,
                "seg": [{
                    "id": 0,
                    "fx": 67,
                    "pal": 9
                }]
            });
            showStatus('‚úì Cold aplicado');
        }

        async function applyPurpleRainDesign() {
            const purpleColor = '#8b00ff';
            updateAllLEDsVisual(purpleColor);
            
            const rgb = hexToRgb(purpleColor);
            
            await sendMQTTCommand({
                "on": true,
                "bri": currentBrightness,
                "seg": [{
                    "id": 0,
                    "fx": 0,
                     "col": [applyColorOrder(rgb.r, rgb.g, rgb.b)]
                }]
            });
            showStatus('‚úì Purple Rain aplicado');
        }

        async function applyDominicanDesign() {
            addDebugLog('üá©üá¥ Aplicando Dominican', 'info');
            const third = Math.floor(totalLeds / 3);
            
            for (let i = 0; i < totalLeds; i++) {
                let colorHex;
                if (i < third) {
                    colorHex = '#0000ff';
                } else if (i < third * 2) {
                    colorHex = '#ffffff';
                } else {
                    colorHex = '#ff0000';
                }
                updateLEDVisual(i, colorHex, false);
            }
            ledMeshes.forEach(mesh => mesh.material.needsUpdate = true);
            await sendMQTTCommand({
                "on": true,
                "bri": currentBrightness,
                "seg": [{
                    "id": 0,
                    "fx": 2,
                    "pal": 255
                }]
            });
            showStatus('‚úì Dominican aplicado üá©üá¥');
        }
        
        // EFECTOS ANIMADOS (mantener todas las funciones existentes)
        function runAnimatedEffect(effectName, sendToWLED = true) {
            if (effectAnimationInterval) {
                clearInterval(effectAnimationInterval);
            }
            if (localAnimationInterval) {
                clearInterval(localAnimationInterval);
            }

            currentLocalAnimation = effectName;
            showStatus(`üîÑ Animaci√≥n "${effectName}" iniciada`);
            addDebugLog(`üé¨ Iniciando animaci√≥n: ${effectName}`, 'info');

            // Mapeo de efectos a sus n√∫meros de FX, paletas y funciones de animaci√≥n
            const effectMap = {
                'Fire': { fx: 45, pal: 35, animate: animateFire }, // Fire Flicker con Fire palette
                'Chase': { fx: 28, animate: animateChase },
                'Twinkle': { fx: 17, animate: animateTwinkle },
                'Sparkle': { fx: 20, animate: animateSparkle },
                'Ripple': { fx: 79, animate: animateRipple },
                'Blink': { fx: 1, animate: animateBlink },
                'Scan': { fx: 10, animate: animateScan },
                'Waves': { fx: 67, animate: animateWaves },
                'Fairy': { fx: 49, animate: animateFairy },
                'Flow': { fx: 110, animate: animateFlow }
            };

            const effect = effectMap[effectName];
            if (effect) {
                effect.animate();
                if (sendToWLED) {
                    sendWLEDEffect(effect.fx, effect.pal || null);
                }
            }
        }

        async function sendWLEDEffect(fxNumber, paletteNumber = null) {
            const rgb = hexToRgb(selectedColor);
            const colorArray = applyColorOrder(rgb.r, rgb.g, rgb.b);

            const segmentConfig = {
                "id": 0,
                "fx": fxNumber,
                "col": [colorArray, [0, 0, 0], [0, 0, 0]]
            };

            // Add palette if specified
            if (paletteNumber !== null) {
                segmentConfig.pal = paletteNumber;
            }

            await sendMQTTCommand({
                "on": true,
                "bri": currentBrightness,
                "mainseg": 0,
                "seg": [segmentConfig]
            });
        }

        // Apply a color palette - mantiene el efecto actual y solo cambia la paleta
        async function setPalette(paletteId) {
            addDebugLog(`üé® Cambiando palette a: ${paletteId} (manteniendo efecto ${currentEffectId})`, 'info');

            // Guardar la paleta actual
            currentPaletteId = paletteId;

            // Definir colores base para paletas especiales
            const paletteBaseColors = {
                2: '#9B30FF',      // Purple Rain - morado vibrante
                6: '#FF1493',      // Party - magenta/rosa vibrante (rainbow sin verde)
                7: '#87CEEB',      // Cloud - azul cielo suave
                8: '#FF4500',      // Lava - naranja lava
                9: '#006994',      // Ocean - azul oc√©ano
                10: '#9ACD32',     // Forest - verde amarillento (yellow-green)
                11: '#FF0000',     // Rainbow - rojo inicial
                13: '#FF6347',     // Sunset - naranja/rojo atardecer
                20: '#FFB6C1',     // Pastel - rosa pastel suave
                26: '#20B2AA',     // Beach - teal/turquesa
                35: '#FF4500',     // Fire - naranja/rojo fuego
                48: '#E74C3C',     // C9 (Christmas) - rojo navide√±o
                50: '#00FF7F',     // Aurora - verde aurora boreal
                255: '#0038A8'     // Dominican - azul de la bandera
            };

            // Si la paleta tiene un color base definido, usarlo
            let colorToUse = selectedColor;
            if (paletteBaseColors[paletteId]) {
                colorToUse = paletteBaseColors[paletteId];
                selectedColor = colorToUse;
                document.getElementById('ledColor').value = colorToUse;
                addDebugLog(`üé® Color base establecido a ${colorToUse} para palette ${paletteId}`, 'info');
            }

            const rgb = hexToRgb(colorToUse);
            const colorArray = applyColorOrder(rgb.r, rgb.g, rgb.b);

            // Aplicar la paleta con el efecto actual
            await sendMQTTCommand({
                "on": true,
                "bri": currentBrightness,
                "mainseg": 0,
                "seg": [{
                    "id": 0,
                    "fx": currentEffectId,
                    "pal": paletteId,
                    "col": [colorArray, [0, 0, 0], [0, 0, 0]]
                }]
            });

            // Si est√° en modo Solid (fx: 0), actualizar visualizaci√≥n inmediatamente
            if (currentEffectId === 0) {
                updateAllLEDsVisual(colorToUse);
            }

            showStatus(`‚úì Palette ${paletteId} aplicada con efecto ${currentEffectId}`);
        }

        // Run an effect mode - usa la paleta actual
        async function runEffect(fxId) {
            addDebugLog(`‚ö° Aplicando efecto: fx=${fxId} con palette=${currentPaletteId}`, 'info');

            // Guardar el efecto actual
            currentEffectId = fxId;

            // Stop any local animations
            if (effectAnimationInterval) clearInterval(effectAnimationInterval);
            if (localAnimationInterval) clearInterval(localAnimationInterval);

            const rgb = hexToRgb(selectedColor);
            const colorArray = applyColorOrder(rgb.r, rgb.g, rgb.b);

            // Aplicar el efecto con la paleta actual
            await sendMQTTCommand({
                "on": true,
                "bri": currentBrightness,
                "mainseg": 0,
                "seg": [{
                    "id": 0,
                    "fx": fxId,
                    "pal": currentPaletteId,
                    "col": [colorArray, [0, 0, 0], [0, 0, 0]]
                }]
            });

            // Mostrar color base de la paleta en la visualizaci√≥n
            // Las animaciones reales las maneja WLED en el hardware
            // La visualizaci√≥n local solo muestra el color base para no confundir
            if (fxId === 0) {
                // Solid: mostrar el color seleccionado
                updateAllLEDsVisual(selectedColor);
            } else {
                // Efectos animados: mostrar color base de la paleta
                // WLED maneja la animaci√≥n real en el hardware
                updateAllLEDsVisual(selectedColor);
            }

            showStatus(`‚úì Effect ${fxId} aplicado con palette ${currentPaletteId}`);
        }

        // Helper to get effect name from ID
        function getEffectName(fxId) {
            const effectNames = {
                1: 'Blink', 9: 'Rainbow', 10: 'Scan', 17: 'Twinkle', 20: 'Sparkle',
                28: 'Chase', 45: 'Fire', 67: 'Waves', 79: 'Ripple', 110: 'Flow'
            };
            return effectNames[fxId] || null;
        }

        // Helper to get animation function from ID
        function getAnimationFunction(fxId) {
            const animations = {
                1: animateBlink, 10: animateScan, 17: animateTwinkle, 20: animateSparkle,
                28: animateChase, 45: animateFire, 67: animateWaves, 79: animateRipple, 110: animateFlow
            };
            return animations[fxId] || null;
        }

        function animateFire() {
            effectAnimationInterval = setInterval(() => {
                for (let i = 0; i < totalLeds; i++) {
                    const intensity = Math.random();
                    const r = 255;
                     const g = Math.floor(intensity * 150);
                    const b = 0;
                    const hexColor = rgbToHex(r, g, b);
                    updateLEDVisual(i, hexColor, false);
                 }
                ledMeshes.forEach(mesh => mesh.material.needsUpdate = true);
            }, 100);
        }

        function animateChase() {
            let pos = 0;
            effectAnimationInterval = setInterval(() => {
                for (let i = 0; i < totalLeds; i++) {
                    if (i % 10 === pos) {
                        updateLEDVisual(i, selectedColor, false);
                     } else {
                        updateLEDVisual(i, '#000000', false);
                    }
                }
                ledMeshes.forEach(mesh => mesh.material.needsUpdate = true);
                 pos = (pos + 1) % 10;
            }, 100);
        }

        function animateTwinkle() {
            effectAnimationInterval = setInterval(() => {
                for (let i = 0; i < totalLeds; i++) {
                    if (Math.random() > 0.95) {
                        updateLEDVisual(i, '#ffffff', false);
                    } else {
                        updateLEDVisual(i, selectedColor, false);
                    }
                }
                 ledMeshes.forEach(mesh => mesh.material.needsUpdate = true);
            }, 200);
        }

        function animateSparkle() {
            effectAnimationInterval = setInterval(() => {
                for (let i = 0; i < totalLeds; i++) {
                    updateLEDVisual(i, selectedColor, false);
                }
                 const sparkleIndex = Math.floor(Math.random() * totalLeds);
                updateLEDVisual(sparkleIndex, '#ffffff', false);
                ledMeshes.forEach(mesh => mesh.material.needsUpdate = true);
            }, 100);
        }

        function animateRipple() {
            let offset = 0;
            effectAnimationInterval = setInterval(() => {
                for (let i = 0; i < totalLeds; i++) {
                    const distance = Math.abs(i - totalLeds/2);
                    const wave = Math.sin((distance + offset) * 0.3) * 0.5 + 0.5;
                     const rgb = hexToRgb(selectedColor);
                    const hexColor = rgbToHex(
                        Math.floor(rgb.r * wave),
                        Math.floor(rgb.g * wave),
                         Math.floor(rgb.b * wave)
                    );
                    updateLEDVisual(i, hexColor, false);
                }
                ledMeshes.forEach(mesh => mesh.material.needsUpdate = true);
                 offset += 1;
            }, 80);
        }

        function animateBlink() {
            let on = true;
            localAnimationInterval = setInterval(() => {
                if (on) {
                    updateAllLEDsVisual(selectedColor);
                } else {
                     updateAllLEDsVisual('#000000');
                }
                on = !on;
            }, 500);
        }
        
        function animateScan() {
            let currentLed = 0;
            localAnimationInterval = setInterval(() => {
                for (let i = 0; i < totalLeds; i++) {
                    if (i === currentLed) {
                        updateLEDVisual(i, selectedColor, false);
                    } else {
                        updateLEDVisual(i, '#000000', false);
                    }
                }
                ledMeshes.forEach(mesh => mesh.material.needsUpdate = true);
                
                 currentLed = (currentLed + 1) % totalLeds;
            }, 50);
        }
        
        function animateWaves() {
            let offset = 0;
            localAnimationInterval = setInterval(() => {
                const rgb = hexToRgb(selectedColor);
                
                for (let i = 0; i < totalLeds; i++) {
                    const wave = Math.sin((i + offset) * 0.2) * 0.5 + 0.5;
                     const waveColor = rgbToHex(
                        Math.floor(rgb.r * wave),
                        Math.floor(rgb.g * wave),
                        Math.floor(rgb.b * wave)
                     );
                    updateLEDVisual(i, waveColor, false);
                }
                ledMeshes.forEach(mesh => mesh.material.needsUpdate = true);
                
                 offset += 1;
            }, 100);
        }
        
        function animateFairy() {
            localAnimationInterval = setInterval(() => {
                for (let i = 0; i < totalLeds; i++) {
                    if (Math.random() > 0.7) {
                         updateLEDVisual(i, selectedColor, false);
                    } else {
                        updateLEDVisual(i, '#000000', false);
                    }
                }
                 ledMeshes.forEach(mesh => mesh.material.needsUpdate = true);
            }, 200);
        }
        
        function animateFlow() {
            let hue = 0;
            localAnimationInterval = setInterval(() => {
                for (let i = 0; i < totalLeds; i++) {
                    const ledHue = (hue + (i * 360 / totalLeds)) % 360;
                    const color = hslToRgb(ledHue, 100, 50);
                     const hexColor = rgbToHex(color.r, color.g, color.b);
                    updateLEDVisual(i, hexColor, false);
                }
                ledMeshes.forEach(mesh => mesh.material.needsUpdate = true);
                
                
                hue = (hue + 5) % 360;
            }, 100);
        }

        function stopAllAnimations() {
            if (effectAnimationInterval) {
                clearInterval(effectAnimationInterval);
                effectAnimationInterval = null;
            }
            if (localAnimationInterval) {
                clearInterval(localAnimationInterval);
                localAnimationInterval = null;
            }
            currentLocalAnimation = null;
            addDebugLog('‚èπ Animaci√≥n detenida', 'info');
            // No mostrar status aqu√≠, es muy ruidoso
        }
        
        // BRILLO
        let brightnessTimeout = null;
        function setBrightness(value) {
            currentBrightness = parseInt(value);
            updateBrightnessLabel(value);

            // Guardar brillo en localStorage para persistencia local
            localStorage.setItem('lastBrightness', currentBrightness.toString());

            // No es necesario actualizar el visual aqu√≠, WLED lo maneja

            if (brightnessTimeout) {
                clearTimeout(brightnessTimeout);
            }

            brightnessTimeout = setTimeout(() => {
                addDebugLog(`üí° Aplicando brillo: ${currentBrightness}`, 'info');
                sendMQTTCommand({"bri": currentBrightness});

                // Publicar brillo en MQTT para sincronizar entre dispositivos
                if (mqttClient && mqttClient.connected) {
                    mqttClient.publish('wled/tree/brightness', currentBrightness.toString(), { retain: true });
                }
            }, 300); // 300ms debounce
        }
        
        function updateBrightnessLabel(value) {
            const percent = Math.round(value / 2.55);
            document.getElementById('brightVal').textContent = `${percent}%`;
        }

        // DISE√ëOS GUARDADOS (mantener todas las funciones existentes)
        function saveDesign() {
            const name = document.getElementById('designName').value.trim();
            if (!name) {
                showStatus('‚ùå Escribe un nombre para el dise√±o.', true);
                return;
            }
            
            const designToSave = {};
            for(const [index, color] of Object.entries(ledColors)) {
                if (color !== '#333333' && color !== '#000000') {
                    designToSave[index] = color;
                }
            }

            if (Object.keys(designToSave).length === 0) {
                 showStatus('‚ùå No hay LEDs encendidos para guardar.', true);
                 return;
            }

            let designs = JSON.parse(localStorage.getItem('wledDesigns')) || {};
            designs[name] = designToSave;
            localStorage.setItem('wledDesigns', JSON.stringify(designs));
            
            showStatus(`‚úì Dise√±o "${name}" guardado.`);
            addDebugLog(`üíæ Dise√±o guardado: ${name}`, 'success');
            document.getElementById('designName').value = '';
            loadDesigns();
        }

        function loadDesigns() {
            const designs = JSON.parse(localStorage.getItem('wledDesigns')) ||
            {};
            const listDiv = document.getElementById('designsList');
            listDiv.innerHTML = '';
            
            if (Object.keys(designs).length === 0) {
                listDiv.innerHTML = '<p style="color: #666; font-size: 14px;">No hay dise√±os guardados.</p>';
                return;
            }
            
            Object.keys(designs).forEach(name => {
                const item = document.createElement('div');
                item.className = 'design-item';
                item.innerHTML = `
                     <span>${escapeHTML(name)}</span>
                    <div>
                        <button onclick="applyDesign('${escapeHTML(name)}')">Cargar</button>
                        <button class="delete-btn" onclick="deleteDesign('${escapeHTML(name)}')">X</button>
                    </div>
                 `;
                listDiv.appendChild(item);
            });
        }

        async function applyDesign(name) {
            const designs = JSON.parse(localStorage.getItem('wledDesigns')) ||
            {};
            const design = designs[name];
            
            if (!design) {
                showStatus('‚ùå No se encontr√≥ el dise√±o.', true);
                return;
            }

            stopAllAnimations();
            
            const payload_i = [];
            for (let i = 0; i < totalLeds; i++) {
                ledColors[i] = '#333333';
                updateLEDVisual(i, '#333333', false);
            }
            
            for(const [index, color] of Object.entries(design)) {
                const rgb = hexToRgb(color);
                const idx = parseInt(index);
                payload_i.push(idx, [rgb.r, rgb.g, rgb.b]);
                
                ledColors[idx] = color;
                updateLEDVisual(idx, color, false);
            }
            
            ledMeshes.forEach(mesh => {
                mesh.material.needsUpdate = true;
            });
            await sendMQTTCommand({
                "on": true,
                "seg": [{ "fx": 0, "i": payload_i }]
            });
            showStatus(`‚úì Dise√±o "${name}" cargado.`);
            addDebugLog(`üìÇ Dise√±o cargado: ${name}`, 'success');
        }

        function deleteDesign(name) {
            if (!confirm(`¬øSeguro que quieres borrar el dise√±o "${name}"?`)) {
                return;
            }
            let designs = JSON.parse(localStorage.getItem('wledDesigns')) || {};
            delete designs[name];
            localStorage.setItem('wledDesigns', JSON.stringify(designs));
            showStatus(`‚úì Dise√±o "${name}" borrado.`);
            addDebugLog(`üóëÔ∏è Dise√±o eliminado: ${name}`, 'info');
            loadDesigns();
        }
        
        // THREE.JS (mantener todas las funciones existentes)
        function initThreeJS() {
            const canvas = document.getElementById('treeCanvas');
            scene = new THREE.Scene();
            scene.background = null;
            
            camera = new THREE.PerspectiveCamera(50, canvas.clientWidth / canvas.clientHeight, 0.1, 1000);
            camera.position.set(0, 10, 18);
            camera.lookAt(0, 8, 0);
            
            renderer = new THREE.WebGLRenderer({ canvas: canvas, alpha: true, antialias: true });
            renderer.setSize(canvas.clientWidth, canvas.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const pointLight = new THREE.PointLight(0xffffff, 0.8);
            pointLight.position.set(0, 25, 20);
            scene.add(pointLight);
            
            createChristmasTree();
            let isDragging = false;
            let previousMousePosition = { x: 0, y: 0 };
            canvas.addEventListener('mousedown', () => {
                isDragging = true;
            });
            canvas.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    const deltaMove = {
                        x: e.offsetX - previousMousePosition.x,
                        y: e.offsetY - previousMousePosition.y
                     };
                    
                    ledGroup.rotation.y += deltaMove.x * 0.01;
                    ledGroup.rotation.x += deltaMove.y * 0.01;
                 }
                
                previousMousePosition = {
                    x: e.offsetX,
                    y: e.offsetY
                };
             });
            
            canvas.addEventListener('mouseup', () => {
                isDragging = false;
            });
            canvas.addEventListener('click', onCanvasClick);
            
            window.addEventListener('resize', onWindowResize);
            
            animate();
        }
        
        function createStarShape() {
            const shape = new THREE.Shape();
            const outerRadius = 0.5;  // Reducido de 0.8 a 0.5
            const innerRadius = 0.2;  // Reducido de 0.35 a 0.2
            const points = 5;

            for (let i = 0; i < points * 2; i++) {
                const radius = i % 2 === 0 ? outerRadius : innerRadius;
                const angle = (i * Math.PI) / points - Math.PI / 2;
                const x = Math.cos(angle) * radius;
                const y = Math.sin(angle) * radius;

                if (i === 0) {
                    shape.moveTo(x, y);
                } else {
                    shape.lineTo(x, y);
                }
            }
            shape.closePath();
            return shape;
        }

        function createChristmasTree() {
            ledGroup = new THREE.Group();
            const treeHeight = 17;
            const treeRadius = 7;
            const treeGeometry = new THREE.ConeGeometry(treeRadius, treeHeight, 32);
            const treeMaterial = new THREE.MeshPhongMaterial({
                color: 0x0a4d0a,
                transparent: true,
                opacity: 0.7
            });
            const treeMesh = new THREE.Mesh(treeGeometry, treeMaterial);
            treeMesh.position.y = treeHeight / 2;
            ledGroup.add(treeMesh);

            // Create 3D star for tree top
            const starShape = createStarShape();
            const extrudeSettings = {
                depth: 0.2,
                bevelEnabled: true,
                bevelThickness: 0.05,
                bevelSize: 0.05,
                bevelSegments: 2
            };
            const starGeometry = new THREE.ExtrudeGeometry(starShape, extrudeSettings);
            const starMaterial = new THREE.MeshPhongMaterial({
                color: 0xffff00,
                emissive: 0xffdd00,
                emissiveIntensity: 0.4,
                shininess: 100,
                specular: 0xffffff
            });
            const starMesh = new THREE.Mesh(starGeometry, starMaterial);

            // Position star vertically on tree top
            starMesh.position.y = treeHeight + 0.8;  // Ajustado de 0.5 a 0.8
            starMesh.position.x = 0;
            starMesh.position.z = 0;
            // Rotar ligeramente para dar m√°s dinamismo
            starMesh.rotation.y = Math.PI / 10;  // Peque√±a rotaci√≥n en Y
            starMesh.rotation.z = 0;             // Sin inclinaci√≥n

            ledGroup.add(starMesh);
            const ledsPerLayer = 9;
            const layers = Math.ceil(totalLeds / ledsPerLayer);
            
            let ledIndex = 0;
            for (let layer = 0; layer < layers && ledIndex < totalLeds; layer++) {
                const ledsInThisLayer = Math.min(ledsPerLayer, totalLeds - ledIndex);
                for (let i = 0; i < ledsInThisLayer; i++) {
                    const angleOffset = (i / ledsInThisLayer) * (Math.PI * 2);
                    const y = (layer / layers) * treeHeight;
                    const radiusAtHeight = treeRadius * (1 - (y / treeHeight));
                    const spiralOffset = layer * 0.4;
                    const x = Math.cos(angleOffset + spiralOffset) * radiusAtHeight;
                    const z = Math.sin(angleOffset + spiralOffset) * radiusAtHeight;
                    
                    const ledGeometry = new THREE.SphereGeometry(0.2, 8, 8);
                    const ledMaterial = new THREE.MeshBasicMaterial({ color: 0x333333 });
                    const ledMesh = new THREE.Mesh(ledGeometry, ledMaterial);
                    
                    ledMesh.position.set(x, y, z);
                    ledMesh.userData.ledIndex = ledIndex;
                    ledGroup.add(ledMesh);
                    ledMeshes.push(ledMesh);
                    ledColors[ledIndex] = '#333333';
                    ledPositions[ledIndex] = { x, y, z };
                    
                    ledIndex++;
                }
            }

            scene.add(ledGroup);

            // Marcar que los LEDs est√°n listos
            ledsReady = true;
            addDebugLog(`‚úÖ ${totalLeds} LEDs creados y listos`, 'success');

            // Aplicar estado pendiente de WLED si existe
            if (pendingWLEDState) {
                addDebugLog('üîÑ Aplicando estado pendiente de WLED...', 'info');
                handleWLEDState(pendingWLEDState);
                pendingWLEDState = null;
            }
        }
        
        function onCanvasClick(event) {
            if (!paintMode) return;
            const canvas = document.getElementById('treeCanvas');
            const rect = canvas.getBoundingClientRect();
            
            const mouse = new THREE.Vector2(
                ((event.clientX - rect.left) / rect.width) * 2 - 1,
                -((event.clientY - rect.top) / rect.height) * 2 + 1
            );
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);
            
            const intersects = raycaster.intersectObjects(ledMeshes);
            if (intersects.length > 0) {
                const clickedLED = intersects[0].object;
                const ledIndex = clickedLED.userData.ledIndex;
                
                updateLEDColor(ledIndex, selectedColor);
            }
        }
        
        function animate() {
            requestAnimationFrame(animate);
            ledGroup.rotation.y += 0.001;
            renderer.render(scene, camera);
        }
        
        function onWindowResize() {
            const canvas = document.getElementById('treeCanvas');
            camera.aspect = canvas.clientWidth / canvas.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(canvas.clientWidth, canvas.clientHeight);
        }
        
        // UTILIDADES (mantener todas las funciones existentes)
        function generateStars() {
            const starsContainer = document.getElementById('stars');
            for(let i = 0; i < 100; i++) {
                const star = document.createElement('div');
                star.className = 'star';
                star.style.left = Math.random() * 100 + '%';
                star.style.top = Math.random() * 100 + '%';
                star.style.animationDelay = Math.random() * 3 + 's';
                starsContainer.appendChild(star);
            }
        }

        function showStatus(message, isError = false) {
            const oldMessage = document.querySelector('.status-message');
            if (oldMessage) oldMessage.remove();
            
            const status = document.createElement('div');
            status.className = 'status-message';
            status.textContent = message;
            if (isError) {
                status.style.background = '#dc3545';
            }
            document.body.appendChild(status);
            setTimeout(() => {
                status.remove();
            }, 3000);
        }

        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : null;
        }

        function rgbToHex(r, g, b) {
            return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
        }

        function hslToRgb(h, s, l) {
            s /= 100;
            l /= 100;
            const k = n => (n + h / 30) % 12;
            const a = s * Math.min(l, 1 - l);
            const f = n => l - a * Math.max(-1, Math.min(k(n) - 3, Math.min(9 - k(n), 1)));
            return {
                r: Math.round(255 * f(0)),
                g: Math.round(255 * f(8)),
                b: Math.round(255 * f(4))
            };
        }
        
        function escapeHTML(str) {
            return str.replace(/[&<>"']/g, function(m) {
                return {
                    '&': '&amp;',
                    '<': '&lt;',
                    '>': '&gt;',
                    '"': '&quot;',
                    "'": '&#39;'
                }[m];
            });
        }
        
        // =====================================================
        // INICIALIZACI√ìN
        // =====================================================
        
        // Initialize Supabase client (must be called after SDK loads)
        function initSupabase() {
            if (window.supabase && window.supabase.createClient) {
                supabaseClient = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
                console.log('‚úÖ Supabase client initialized');
                return true;
            } else {
                console.error('‚ùå Supabase SDK not loaded');
                return false;
            }
        }
        
        window.onload = function() {
            // PRIMERO inicializar Supabase
            if (!initSupabase()) {
                console.error('Failed to initialize Supabase');
                document.getElementById('authError').textContent = 'Error: No se pudo cargar el sistema de autenticaci√≥n';
                document.getElementById('authError').classList.add('show');
                return;
            }
            
            // Configurar listener de cambios de autenticaci√≥n
            supabaseClient.auth.onAuthStateChange(async (event, session) => {
                console.log('Auth event:', event);

                if (event === 'SIGNED_IN' && session) {
                    // Verificar l√≠mite de usuarios (especialmente para OAuth)
                    try {
                        const { data: userCount, error: countError } = await supabaseClient.rpc('count_registered_users');

                        if (!countError && userCount > 3) {
                            // Si se excedi√≥ el l√≠mite, cerrar sesi√≥n inmediatamente
                            console.error('L√≠mite de usuarios excedido:', userCount);
                            await supabaseClient.auth.signOut();
                            showAuthError('üö´ L√≠mite de usuarios alcanzado. Solo se permiten 3 usuarios registrados.');
                            document.getElementById('authOverlay').classList.remove('hidden');
                            return;
                        }
                    } catch (e) {
                        console.error('Error verificando l√≠mite en auth change:', e);
                    }

                    currentUser = session.user;
                    document.getElementById('authOverlay').classList.add('hidden');
                    updateUserInfo(session.user);
                } else if (event === 'SIGNED_OUT') {
                    currentUser = null;
                    document.getElementById('authOverlay').classList.remove('hidden');
                    hideUserInfo();
                } else if (event === 'PASSWORD_RECOVERY') {
                    // Mostrar formulario para cambiar contrase√±a
                    const newPassword = prompt('Ingresa tu nueva contrase√±a:');
                    if (newPassword) {
                        const passwordCheck = checkPasswordStrength(newPassword);
                        if (passwordCheck.valid) {
                            supabaseClient.auth.updateUser({ password: newPassword })
                                .then(() => alert('Contrase√±a actualizada exitosamente'))
                                .catch(err => alert('Error al actualizar contrase√±a: ' + err.message));
                        } else {
                            alert('La contrase√±a no es lo suficientemente fuerte');
                        }
                    }
                }
            });
            
            // AHORA verificar sesi√≥n de autenticaci√≥n
            checkAuthSession();

            addDebugLog('üöÄ Aplicaci√≥n iniciada', 'success');
            addDebugLog('üìù Versi√≥n completa con Scheduler', 'info');

            // Cargar √∫ltimo brillo conocido desde localStorage
            const savedBrightness = localStorage.getItem('lastBrightness');
            if (savedBrightness) {
                const brightness = parseInt(savedBrightness);
                currentBrightness = brightness;
                document.getElementById('brightness').value = brightness;
                updateBrightnessLabel(brightness);
                addDebugLog(`üí° Brillo restaurado: ${brightness}`, 'info');
            }

            initThreeJS();
            generateStars();
            loadDesigns();
            loadSchedules();
            loadTimezone(); // Cargar zona horaria guardada
            
            // PRIMERO establecer conexi√≥n MQTT
            setTimeout(() => {
                initMQTT();
            }, 500);
            
            // DESPU√âS iniciar verificaci√≥n de horarios (solo si hay conexi√≥n)
            setTimeout(() => {
                // Verificar horarios cada 20 segundos para mayor precisi√≥n
                schedulerInterval = setInterval(() => {
                    checkSchedules();
                }, 20000);

                // Primera verificaci√≥n inmediata despu√©s de iniciar
                setTimeout(() => {
                    checkSchedules();
                }, 3000);
            }, 2000);
        };
    </script>
</body>
</html>
